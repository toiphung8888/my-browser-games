<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Th·ªß Th√†nh Chi·∫øn Thu·∫≠t: X√°c S·ªëng Tr·ªói D·∫≠y (v3.3 Fix)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #0f172a; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; user-select: none; }
        #game-container { position: relative; width: 100vw; height: 100vh; }
        canvas { display: block; background: #4ade80; cursor: default; }
        
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        
        .top-bar { 
            display: flex; justify-content: space-between; align-items: center; padding: 10px 20px; 
            background: rgba(15, 23, 42, 0.95); color: white; pointer-events: auto;
            border-bottom: 2px solid #fbbf24; backdrop-filter: blur(4px);
            box-shadow: 0 4px 10px rgba(0,0,0,0.5);
        }
        .stat-group { display: flex; gap: 20px; }
        .stat-box { display: flex; align-items: center; gap: 8px; font-weight: bold; font-size: 1.1rem; }
        
        .dev-switch-container {
            display: flex; align-items: center; gap: 10px;
            background: #334155; padding: 5px 15px; border-radius: 20px; border: 1px solid #475569;
        }
        .switch { position: relative; display: inline-block; width: 40px; height: 20px; }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider {
            position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0;
            background-color: #64748b; transition: .4s; border-radius: 20px;
        }
        .slider:before {
            position: absolute; content: ""; height: 16px; width: 16px; left: 2px; bottom: 2px;
            background-color: white; transition: .4s; border-radius: 50%;
        }
        input:checked + .slider { background-color: #ef4444; }
        input:checked + .slider:before { transform: translateX(20px); }

        #btn-provoke {
            position: absolute; top: 120px; left: 40px; pointer-events: auto;
            background: linear-gradient(to bottom, #7f1d1d, #450a0a);
            color: #fca5a5; border: 2px solid #ef4444;
            padding: 10px 20px; border-radius: 8px; font-weight: bold;
            box-shadow: 0 0 15px rgba(239, 68, 68, 0.4);
            cursor: pointer; display: none;
            font-size: 0.9rem; text-transform: uppercase; letter-spacing: 1px;
            transition: 0.1s; animation: pulseRed 2s infinite;
        }
        #btn-provoke:active { transform: scale(0.95); }
        @keyframes pulseRed { 0% { box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.7); } 70% { box-shadow: 0 0 0 10px rgba(239, 68, 68, 0); } 100% { box-shadow: 0 0 0 0 rgba(239, 68, 68, 0); } }

        .menu-container {
            position: absolute; bottom: 10px; left: 50%; transform: translateX(-50%);
            pointer-events: auto; transition: transform 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            display: flex; flex-direction: column; align-items: center; gap: 5px;
        }
        .menu-container.collapsed { transform: translateX(-50%) translateY(320px); }

        .toggle-btn {
            background: #334155; color: #cbd5e1; border: 2px solid #475569;
            padding: 4px 20px; border-radius: 20px 20px 0 0; cursor: pointer;
            font-size: 0.8rem; font-weight: bold; text-transform: uppercase;
            box-shadow: 0 -2px 5px rgba(0,0,0,0.2);
        }
        
        .build-menu {
            display: flex; flex-direction: column; gap: 8px; padding: 10px;
            background: rgba(15, 23, 42, 0.95); border-radius: 16px; 
            border: 2px solid #475569; box-shadow: 0 10px 25px rgba(0,0,0,0.6);
        }
        .menu-row { display: flex; gap: 8px; justify-content: center; }
        .menu-label { color: #94a3b8; font-size: 0.7rem; text-transform: uppercase; margin-bottom: -5px; margin-left: 5px; font-weight: bold; }

        .tower-btn {
            position: relative; width: 65px; height: 65px;
            background: #1e293b; border: 2px solid #334155; border-radius: 8px;
            cursor: pointer; transition: all 0.2s;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            color: #94a3b8; font-size: 0.65rem; text-align: center;
        }
        .tower-btn:hover { transform: translateY(-3px); border-color: #fbbf24; background: #334155; color: white; }
        .tower-btn.selected { border-color: #facc15; box-shadow: 0 0 10px rgba(250, 204, 21, 0.4); transform: translateY(-5px); background: #0f172a; color: white; }
        .tower-btn.disabled { opacity: 0.4; filter: grayscale(1); cursor: not-allowed; transform: none; }
        
        .cd-overlay {
            position: absolute; top:0; left:0; width:100%; height:100%;
            background: rgba(0,0,0,0.7); border-radius: 6px;
            display: flex; align-items: center; justify-content: center;
            color: #fff; font-size: 1.2rem; font-weight: bold; display: none;
        }

        .hero-btn { border-color: #6366f1; background: #312e81; }
        .hero-btn:hover { border-color: #818cf8; background: #3730a3; }
        .hero-btn.selected { border-color: #a5b4fc; box-shadow: 0 0 15px rgba(99, 102, 241, 0.5); }
        .hero-cost { color: #22d3ee; font-weight: bold; }

        .spell-btn { border-color: #f43f5e; background: #881337; }
        .spell-btn:hover { border-color: #fb7185; background: #9f1239; }
        .spell-btn.selected { border-color: #fda4af; box-shadow: 0 0 15px rgba(244, 63, 94, 0.5); }

        .tower-icon { font-size: 1.5rem; margin-bottom: 2px; }
        .cost { color: #fbbf24; font-weight: bold; }

        #tower-inspector {
            position: absolute; bottom: 200px; right: 20px; width: 260px;
            background: rgba(15, 23, 42, 0.95); border: 2px solid #64748b; border-radius: 12px;
            padding: 15px; color: white; pointer-events: auto;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            display: none; animation: slideIn 0.2s ease-out;
            backdrop-filter: blur(5px);
        }
        .inspector-header { display: flex; justify-content: space-between; align-items: center; border-bottom: 1px solid #334155; padding-bottom: 8px; margin-bottom: 10px; }
        .inspector-title { font-size: 1.1rem; font-weight: bold; color: #facc15; }
        .close-btn { background: none; border: none; color: #94a3b8; cursor: pointer; font-size: 1.2rem; }
        .stat-row { display: flex; justify-content: space-between; margin-bottom: 6px; font-size: 0.9rem; color: #cbd5e1; }
        .stat-val { font-weight: bold; color: white; }
        .action-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-top: 15px; }
        .action-btn { padding: 8px; border: none; border-radius: 6px; font-weight: bold; cursor: pointer; display: flex; flex-direction: column; align-items: center; font-size: 0.8rem; transition: 0.2s; }
        .btn-upgrade { background: #15803d; color: #dcfce7; } .btn-upgrade:hover { background: #166534; }
        .btn-sell { background: #991b1b; color: #fee2e2; } .btn-sell:hover { background: #7f1d1d; }

        .modal {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(15, 23, 42, 0.95);
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            color: white; z-index: 100; pointer-events: auto;
        }
        .btn-primary {
            padding: 12px 40px; background: linear-gradient(to bottom, #ea580c, #c2410c); color: white;
            border: none; border-radius: 8px; font-size: 1.4rem; cursor: pointer;
            font-weight: bold; margin-top: 20px; transition: 0.2s;
            box-shadow: 0 4px 0 #7c2d12; text-transform: uppercase; letter-spacing: 1px;
        }
        .btn-primary:active { transform: translateY(4px); box-shadow: none; }
        
        .floating-text {
            position: absolute; pointer-events: none; 
            font-weight: 900; text-shadow: 1px 1px 0 #000; font-family: monospace;
            animation: floatUp 1s ease-out forwards;
        }
        @keyframes floatUp { 0% { opacity: 1; transform: translateY(0); } 100% { opacity: 0; transform: translateY(-30px); } }
        
        #screen-flash { position: absolute; top:0; left:0; width:100%; height:100%; background: #991b1b; pointer-events: none; opacity: 0; transition: opacity 0.1s; mix-blend-mode: multiply; z-index: 50; }
    </style>
</head>
<body>

<div id="game-container">
    <canvas id="gameCanvas"></canvas>
    <div id="screen-flash"></div>

    <div id="ui-layer">
        <div class="top-bar">
            <div class="stat-group">
                <div class="stat-box"><span style="color:#ef4444">‚ù§</span> <span id="lives">20</span></div>
                <div class="stat-box"><span style="color:#fbbf24">üí∞</span> <span id="gold">450</span></div>
                <div class="stat-box"><span style="color:#22d3ee">üíé</span> <span id="diamonds">0</span></div>
            </div>

            <div class="dev-switch-container">
                <span style="font-size: 0.8rem; color: #94a3b8; font-weight: bold;">DEV MODE</span>
                <label class="switch">
                    <input type="checkbox" id="devModeToggle" onchange="toggleDevMode()">
                    <span class="slider"></span>
                </label>
            </div>

            <div class="stat-group">
                <div class="stat-box">üåä <span id="wave">1</span></div>
                <div class="stat-box" style="font-size: 0.9rem; color: #94a3b8; min-width: 80px; text-align: right;" id="wave-timer">...</div>
            </div>
        </div>

        <button id="btn-provoke" onclick="spawnProvokeBoss()">üíÄ KHI√äU KH√çCH üíÄ</button>

        <div id="tower-inspector">
            <div class="inspector-header">
                <span class="inspector-title" id="insp-name">Th√°p</span>
                <button class="close-btn" onclick="closeInspector()">‚úï</button>
            </div>
            <div class="stat-row"><span>HP:</span> <span class="stat-val" id="insp-hp">0</span></div>
            <div class="stat-row"><span>S√°t th∆∞∆°ng:</span> <span class="stat-val" id="insp-dmg">0</span></div>
            <div class="stat-row"><span>T·ªëc ƒë·ªô:</span> <span class="stat-val" id="insp-spd">0s</span></div>
            <div class="action-grid">
                <button class="action-btn btn-upgrade" onclick="upgradeSelectedTower()" id="btn-upgrade">
                    <span>N√ÇNG C·∫§P</span> <span style="font-size: 0.9rem" id="upgrade-cost">100$</span>
                </button>
                <button class="action-btn btn-sell" onclick="sellSelectedTower()">
                    <span>B√ÅN</span> <span style="font-size: 0.9rem" id="sell-price">25$</span>
                </button>
            </div>
        </div>

        <div class="menu-container" id="menu-container">
            <div class="toggle-btn" onclick="toggleMenu()">‚ñº Menu X√¢y D·ª±ng ‚ñº</div>
            <div class="build-menu">
                <div class="menu-label">Tr·ª• (D√πng V√†ng)</div>
                <div class="menu-row">
                    <div class="tower-btn" onclick="selectTower('archer')" id="btn-archer">
                        <div class="tower-icon">üèπ</div> <div>Cung</div> <div class="cost">50$</div>
                    </div>
                    <div class="tower-btn" onclick="selectTower('cannon')" id="btn-cannon">
                        <div class="tower-icon">üí£</div> <div>Ph√°o</div> <div class="cost">100$</div>
                    </div>
                    <div class="tower-btn" onclick="selectTower('mage')" id="btn-mage">
                        <div class="tower-icon">üßô‚Äç‚ôÇÔ∏è</div> <div>Ph√©p</div> <div class="cost">150$</div>
                    </div>
                    <div class="tower-btn" onclick="selectTower('tesla')" id="btn-tesla">
                        <div class="tower-icon">‚ö°</div> <div>ƒêi·ªán</div> <div class="cost">250$</div>
                    </div>
                    <div class="tower-btn" onclick="selectSoldier()" id="btn-soldier" style="border-color: #3b82f6;">
                        <div class="tower-icon">üõ°Ô∏è</div> <div>L√≠nh</div> <div class="cost" style="color:#60a5fa">Free</div>
                    </div>
                </div>
                
                <div class="menu-label" style="color:#818cf8; margin-top:5px;">Anh H√πng (D√πng üíé)</div>
                <div class="menu-row">
                    <div class="tower-btn hero-btn" onclick="selectHero('knight')" id="btn-knight">
                        <div class="tower-icon">üó°Ô∏è</div> <div>Hi·ªáp Sƒ©</div> <div class="hero-cost">1üíé</div>
                    </div>
                    <div class="tower-btn hero-btn" onclick="selectHero('ranger')" id="btn-ranger">
                        <div class="tower-icon">üéØ</div> <div>X·∫° Th·ªß</div> <div class="hero-cost">1üíé</div>
                    </div>
                    <div class="tower-btn hero-btn" onclick="selectHero('sorcerer')" id="btn-sorcerer">
                        <div class="tower-icon">üß™</div> <div>Ph√°p S∆∞</div> <div class="hero-cost">1üíé</div>
                    </div>
                    <div class="tower-btn hero-btn" onclick="selectHero('deathgod')" id="btn-deathgod">
                        <div class="tower-icon">üíÄ</div> <div>Th·∫ßn Ch·∫øt</div> <div class="hero-cost">5üíé</div>
                    </div>
                </div>

                <div class="menu-label" style="color:#f43f5e; margin-top:5px;">K·ªπ NƒÉng (Chi·∫øn Thu·∫≠t)</div>
                <div class="menu-row">
                    <div class="tower-btn spell-btn" onclick="castSpell('meteor')" id="btn-meteor">
                        <div class="tower-icon">‚òÑÔ∏è</div> <div>Thi√™n Th·∫°ch</div> <div class="cost">15s</div>
                        <div class="cd-overlay" id="cd-meteor"></div>
                    </div>
                    <div class="tower-btn spell-btn" onclick="castSpell('truck')" id="btn-truck">
                        <div class="tower-icon">üõª</div> <div>Xe B·∫Øt Ma</div> <div class="cost">30s</div>
                        <div class="cd-overlay" id="cd-truck"></div>
                    </div>
                    <div class="tower-btn spell-btn" onclick="castSpell('ufo')" id="btn-ufo">
                        <div class="tower-icon">üõ∏</div> <div>UFO</div> <div class="cost">60s</div>
                        <div class="cd-overlay" id="cd-ufo"></div>
                    </div>
                </div>
            </div>
        </div>
        <div id="floating-text-container"></div>
    </div>

    <div id="start-screen" class="modal">
        <h1 class="text-6xl font-black text-yellow-400 mb-2" style="text-shadow: 4px 4px 0 #7c2d12">V√ôNG ƒê·∫§T CH·∫æT v3.3</h1>
        <p class="text-gray-400 mb-6 tracking-widest uppercase text-sm">C·∫≠p Nh·∫≠t: UFO H·ªßy Di·ªát</p>
        <div class="bg-gray-800 p-6 rounded-lg border border-gray-700 max-w-lg mb-8 text-left text-gray-300 space-y-2">
            <p>üßü <b>X√°c S·ªëng (Zombie):</b> M√°u v√† S√°t th∆∞∆°ng ƒë√£ gi·∫£m ƒë·ªÉ d·ªÖ th·ªü h∆°n.</p>
            <p>‚òÑÔ∏è <b>Thi√™n Th·∫°ch:</b> ƒê√£ s·ª≠a l·ªói ho·∫°t ƒë·ªông! Oanh t·∫°c khu v·ª±c l·ªõn (H·ªìi chi√™u 15s).</p>
            <p>üõ∏ <b>UFO:</b> Xu·∫•t hi·ªán ho√†nh tr√°ng, t·ª± t√¨m di·ªát qu√°i (H·ªìi chi√™u 60s).</p>
            <p>üõª <b>Xe B·∫Øt Ma:</b> Xe b√°n t·∫£i ƒëi tu·∫ßn tra di·ªát Zombie (H·ªìi chi√™u 30s).</p>
            <p>üè∞ <b>Tr·ª•:</b> H√∫t m√°u khi ƒë√°nh c·∫£ Qu√°i l·∫´n Zombie.</p>
        </div>
        <button class="btn-primary" onclick="startGame()">V√†o Tr·∫≠n</button>
    </div>

    <div id="game-over-screen" class="modal" style="display: none;">
        <h1 class="text-6xl font-bold text-red-500 mb-4">TH·∫§T TH·ª¶!</h1>
        <p class="text-2xl mb-6">B·∫°n tr·ª• ƒë∆∞·ª£c: <span id="final-wave" class="text-yellow-400 font-bold">0</span> ƒë·ª£t</p>
        <button class="btn-primary" onclick="location.reload()">Ch∆°i L·∫°i</button>
    </div>
</div>

<script>
const AudioSys = {
    ctx: null,
    init() {
        window.AudioContext = window.AudioContext || window.webkitAudioContext;
        this.ctx = new AudioContext();
    },
    playTone(freq, type, duration, vol = 0.1) {
        if (!this.ctx) return;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = type;
        osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
        gain.gain.setValueAtTime(vol, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + duration);
        osc.connect(gain); gain.connect(this.ctx.destination);
        osc.start(); osc.stop(this.ctx.currentTime + duration);
    },
    playShoot() { this.playTone(600, 'triangle', 0.1, 0.05); },
    playCannon() { this.playTone(80, 'square', 0.4, 0.15); },
    playMagic() { this.playTone(900, 'sine', 0.3, 0.05); },
    playZap() { this.playTone(200, 'sawtooth', 0.1, 0.05); },
    playBuild() { this.playTone(800, 'sine', 0.1, 0.1); },
    playUpgrade() { this.playTone(1000, 'square', 0.2, 0.1); this.playTone(1500, 'sine', 0.4, 0.1); },
    playSell() { this.playTone(300, 'sine', 0.2, 0.1); },
    playExplosion() { this.playTone(100, 'sawtooth', 0.4, 0.2); },
    playHeroSummon() { this.playTone(200, 'square', 0.5, 0.2); this.playTone(400, 'sine', 0.5, 0.2); },
    playBlood() { this.playTone(50, 'sawtooth', 1.0, 0.3); },
    playPoison() { this.playTone(300, 'square', 0.3, 0.05); },
    playSuck() { 
        if(!this.ctx) return;
        const osc = this.ctx.createOscillator(); const gain = this.ctx.createGain();
        osc.frequency.setValueAtTime(200, this.ctx.currentTime);
        osc.frequency.linearRampToValueAtTime(50, this.ctx.currentTime + 0.5);
        gain.gain.setValueAtTime(0.1, this.ctx.currentTime);
        gain.gain.linearRampToValueAtTime(0, this.ctx.currentTime + 0.5);
        osc.connect(gain); gain.connect(this.ctx.destination);
        osc.start(); osc.stop(this.ctx.currentTime + 0.5);
    },
    playZombieMoan() { this.playTone(150, 'sawtooth', 0.8, 0.05); },
    playMeteor() { this.playTone(100, 'sawtooth', 1.5, 0.4); },
    playTruck() { this.playTone(150, 'square', 1.0, 0.1); this.playTone(200, 'sawtooth', 1.0, 0.1); },
    playLaser() { this.playTone(800, 'sine', 0.1, 0.05); this.playTone(1200, 'square', 0.1, 0.05); }
};

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
let mousePos = {x:0, y:0};

const TOWERS_BASE = {
    archer: { name: 'Cung', cost: 50, range: 150, damage: 10, rate: 40, hp: 500 }, 
    cannon: { name: 'Ph√°o', cost: 100, range: 130, damage: 30, rate: 110, aoe: 65, hp: 800 },
    mage:   { name: 'Ph√©p', cost: 150, range: 170, damage: 4, rate: 5, slow: 0.3, hp: 400 }, 
    tesla:  { name: 'ƒêi·ªán', cost: 250, range: 120, damage: 45, rate: 90, stun: 30, multi: 3, hp: 600 }
};

const HEROES_CONFIG = {
    knight:  { name: 'Hi·ªáp Sƒ©', cost: 1, hp: 8000, dmg: 60, rate: 40, range: 35, color: '#fcd34d' },
    ranger:  { name: 'X·∫° Th·ªß',  cost: 1, hp: 1500, dmg: 35, rate: 10, range: 180, color: '#4ade80' },
    sorcerer:{ name: 'Ph√°p S∆∞', cost: 1, hp: 1800, dmg: 10, rate: 180, range: 140, color: '#22c55e' },
    deathgod:{ name: 'Th·∫ßn Ch·∫øt', cost: 5, hp: 8000, dmg: 10, rate: 5, range: 120, color: '#000000' }
};

const SPELLS_CONFIG = {
    meteor: { name: 'Thi√™n Th·∫°ch', cd: 15, color: '#f43f5e' },
    truck: { name: 'Xe B·∫Øt Ma', cd: 30, color: '#3b82f6' },
    ufo: { name: 'UFO', cd: 60, color: '#0ea5e9' }
};

let GAME = {
    width: 0, height: 0, lives: 20, gold: 450, diamonds: 0, wave: 1,
    active: false, gameOver: false, devMode: false, provokeCount: 0,
    path: [], slots: [], decorations: [], bloodStains: [], poisonTraps: [], craters: [],
    enemies: [], zombies: [], towers: [], projectiles: [], soldiers: [], heroes: [], particles: [], allies: [],
    waveTimer: 5, waveDelayTicker: 60, spawnTimer: 0, enemiesToSpawn: [],
    selection: null, selectedTower: null,
    soldierCooldown: 0, soldierMaxCooldown: 12,
    zombieTimer: 0,
    spells: { meteor: 0, truck: 0, ufo: 0 }
};

function initMap() {
    GAME.width = window.innerWidth;
    GAME.height = window.innerHeight;
    canvas.width = GAME.width;
    canvas.height = GAME.height;
    const w = GAME.width; const h = GAME.height;
    
    GAME.path = [
        {x: 0, y: h * 0.15}, {x: w * 0.15, y: h * 0.15}, {x: w * 0.15, y: h * 0.5},
        {x: w * 0.35, y: h * 0.5}, {x: w * 0.35, y: h * 0.2}, {x: w * 0.60, y: h * 0.2},
        {x: w * 0.60, y: h * 0.7}, {x: w * 0.40, y: h * 0.7}, {x: w * 0.40, y: h * 0.85},
        {x: w * 0.85, y: h * 0.85}, {x: w * 0.85, y: h * 0.5}, {x: w, y: h * 0.5} 
    ];

    GAME.slots = [];
    for (let i = 0; i < GAME.path.length - 1; i++) {
        let p1 = GAME.path[i]; let p2 = GAME.path[i+1];
        let dist = Math.hypot(p2.x - p1.x, p2.y - p1.y);
        let steps = Math.floor(dist / 70); 
        for (let j = 1; j < steps; j++) {
            let t = j / steps;
            let cx = p1.x + (p2.x - p1.x) * t; let cy = p1.y + (p2.y - p1.y) * t;
            let offset = 60;
            let dx = p2.x - p1.x; let dy = p2.y - p1.y;
            let len = Math.hypot(dx, dy);
            let perpX = -dy / len; let perpY = dx / len;
            addSlot(cx + perpX * offset, cy + perpY * offset);
            addSlot(cx - perpX * offset, cy - perpY * offset);
        }
    }

    GAME.decorations = [];
    for(let k=0; k<40; k++) {
        GAME.decorations.push({
            x: Math.random() * w, y: Math.random() * h,
            r: 5 + Math.random() * 25, type: Math.random() > 0.3 ? 'tree' : 'rock',
            color: Math.random() > 0.3 ? '#166534' : '#64748b'
        });
    }
}

function addSlot(x, y) {
    for (let i = 0; i < GAME.path.length - 1; i++) {
        let p1 = GAME.path[i]; let p2 = GAME.path[i+1];
        if (Math.hypot(x - p1.x, y - p1.y) < 45) return;
        if (Math.hypot(x - p2.x, y - p2.y) < 45) return;
    }
    GAME.slots.push({x: x, y: y, occupied: false, r: 25});
}

function isNearPath(x, y) {
    for (let i = 0; i < GAME.path.length - 1; i++) {
        let p1 = GAME.path[i]; let p2 = GAME.path[i+1];
        let A = x - p1.x; let B = y - p1.y;
        let C = p2.x - p1.x; let D = p2.y - p1.y;
        let dot = A * C + B * D;
        let len_sq = C * C + D * D;
        let param = -1;
        if (len_sq !== 0) param = dot / len_sq;
        let xx, yy;
        if (param < 0) { xx = p1.x; yy = p1.y; }
        else if (param > 1) { xx = p2.x; yy = p2.y; }
        else { xx = p1.x + param * C; yy = p1.y + param * D; }
        let dx = x - xx; let dy = y - yy;
        if (Math.hypot(dx, dy) < 80) return true;
    }
    return false;
}

class BloodStain {
    constructor(x, y) { this.x = x; this.y = y; this.life = 60; this.maxLife = 60; this.shape = []; this.r = 10 + Math.random()*15; for(let i=0; i<8; i++) { let a = (i/8)*Math.PI*2; let rOff = this.r*(0.5+Math.random()*0.8); this.shape.push({x: Math.cos(a)*rOff, y: Math.sin(a)*rOff}); } }
    draw() { if(this.life<=0) return; ctx.save(); ctx.translate(this.x, this.y); ctx.globalAlpha = (this.life/this.maxLife)*0.8; ctx.fillStyle = '#991b1b'; ctx.beginPath(); ctx.moveTo(this.shape[0].x, this.shape[0].y); for(let p of this.shape) ctx.lineTo(p.x, p.y); ctx.fill(); ctx.restore(); this.life--; }
}

class PoisonTrap {
    constructor(x, y) { this.x = x; this.y = y; this.life = 240; this.r = 90; this.smokes = []; for(let i=0; i<15; i++) { this.smokes.push({ x: (Math.random()-0.5)*this.r*1.2, y: (Math.random()-0.5)*this.r*1.2, r: 10+Math.random()*15, a: Math.random()*Math.PI*2, s: 0.5+Math.random() }); } }
    update() { this.life--; let allEnemies = [...GAME.enemies, ...GAME.zombies]; allEnemies.forEach(e => { if (Math.hypot(e.x - this.x, e.y - this.y) < this.r) { e.slowed = 10; e.silenced = 10; e.takeDamage(0.5); } }); this.smokes.forEach(s => { s.y -= 0.2; s.a += 0.02; if(Math.hypot(s.x, s.y) > this.r) { s.x = (Math.random()-0.5)*this.r; s.y = (Math.random()-0.5)*this.r; } }); }
    draw() { ctx.save(); ctx.translate(this.x, this.y); let grad = ctx.createRadialGradient(0, 0, 10, 0, 0, this.r); grad.addColorStop(0, 'rgba(34, 197, 94, 0.4)'); grad.addColorStop(1, 'rgba(34, 197, 94, 0)'); ctx.fillStyle = grad; ctx.beginPath(); ctx.arc(0, 0, this.r, 0, Math.PI*2); ctx.fill(); ctx.fillStyle = 'rgba(74, 222, 128, 0.6)'; this.smokes.forEach(s => { let flicker = 1 + Math.sin(Date.now()*0.005 + s.x)*0.2; ctx.beginPath(); ctx.arc(s.x, s.y, s.r * flicker, 0, Math.PI*2); ctx.fill(); }); ctx.restore(); }
}

class Zombie {
    constructor(type, x=null, y=null) {
        if (x === null) {
            let attempts = 0;
            do {
                this.x = Math.random() * GAME.width;
                this.y = Math.random() * GAME.height;
                attempts++;
            } while (isNearPath(this.x, this.y) && attempts < 50);
        } else {
            this.x = x; this.y = y;
        }
        this.type = type;
        this.state = 'digging'; 
        this.digTimer = 90;
        this.wobble = Math.random() * 10;
        this.attackTimer = 0;
        this.isDead = false; 
        
        if (type === 'big') {
            this.hp = 400 + GAME.wave * 50; 
            this.maxHp = this.hp;
            this.damage = 25 + GAME.wave; 
            this.speed = 0.5;
            this.r = 25;
        } else { 
            this.hp = 80 + GAME.wave * 15; 
            this.maxHp = this.hp;
            this.damage = 8 + GAME.wave * 0.5; 
            this.speed = 1.0 + Math.random()*0.5;
            this.r = 12;
        }
    }
    update() {
        if (this.state === 'digging') {
            this.digTimer--;
            if (this.digTimer <= 0) this.state = 'active';
            return;
        }
        this.wobble += 0.2;
        let target = null;
        let minD = Infinity;
        let targets = [...GAME.towers, ...GAME.soldiers, ...GAME.heroes];
        for (let t of targets) {
            let d = Math.hypot(t.x - this.x, t.y - this.y);
            if (d < minD) { minD = d; target = t; }
        }
        if (target) {
            let dx = target.x - this.x; let dy = target.y - this.y;
            let dist = Math.hypot(dx, dy);
            let range = this.r + (target.isHero ? 20 : (target.r || 20)); 
            if (dist < range + 5) {
                if (this.attackTimer <= 0) {
                    target.takeDamage(this.damage);
                    GAME.particles.push(new Particle(target.x, target.y, '#ef4444', 1));
                    this.attackTimer = 60;
                }
            } else {
                this.x += (dx/dist) * this.speed;
                this.y += (dy/dist) * this.speed;
            }
        } else {
            this.x += Math.sin(this.wobble * 0.1) * 0.5;
            this.y += Math.cos(this.wobble * 0.1) * 0.5;
        }
        if (this.attackTimer > 0) this.attackTimer--;
    }
    takeDamage(amt) {
        if (this.isDead) return false;
        this.hp -= amt;
        GAME.particles.push(new Particle(this.x, this.y, '#65a30d', 1));
        if (this.hp <= 0) {
            this.isDead = true;
            if (this.type === 'big') {
                AudioSys.playExplosion();
                GAME.particles.push(new Particle(this.x, this.y, '#84cc16', 5));
                for(let i=0; i<3; i++) {
                    let z = new Zombie('normal', this.x + (Math.random()-0.5)*30, this.y + (Math.random()-0.5)*30);
                    z.state = 'active';
                    GAME.zombies.push(z);
                }
            }
            return true;
        }
        return false;
    }
    draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        if (this.state === 'digging') {
            let progress = 1 - (this.digTimer / 90);
            ctx.fillStyle = '#78350f';
            ctx.beginPath(); ctx.ellipse(0, 10, 15 * progress, 5 * progress, 0, 0, Math.PI*2); ctx.fill();
            if (progress > 0.5) {
                ctx.fillStyle = '#65a30d';
                ctx.fillRect(-8, -5 * progress, 4, 10);
                ctx.fillRect(4, -5 * progress, 4, 10);
            }
        } else {
            let lean = Math.sin(this.wobble) * 0.2;
            ctx.rotate(lean);
            ctx.fillStyle = 'rgba(0,0,0,0.4)'; ctx.beginPath(); ctx.ellipse(0, 5, 8, 3, 0, 0, Math.PI*2); ctx.fill();
            if (this.type === 'big') {
                ctx.fillStyle = '#3f3f46'; ctx.fillRect(-15, -20, 30, 35);
                ctx.fillStyle = '#4d7c0f'; ctx.beginPath(); ctx.arc(0, -25, 12, 0, Math.PI*2); ctx.fill();
                ctx.fillStyle = '#000'; ctx.fillRect(-5, -28, 3, 3); ctx.fillRect(2, -28, 3, 3);
                ctx.fillRect(-20, -15, 8, 25); ctx.fillRect(12, -15, 8, 25);
            } else {
                ctx.fillStyle = '#52525b'; ctx.fillRect(-8, -10, 16, 20);
                ctx.fillStyle = '#65a30d'; ctx.beginPath(); ctx.arc(0, -14, 7, 0, Math.PI*2); ctx.fill();
                ctx.fillRect(-12, -8, 24, 4);
            }
            ctx.rotate(-lean);
            ctx.fillStyle = 'red'; ctx.fillRect(-10, -40, 20, 3);
            ctx.fillStyle = '#65a30d'; ctx.fillRect(-10, -40, 20 * (this.hp/this.maxHp), 3);
        }
        ctx.restore();
    }
}

class Enemy {
    constructor(type) { this.pathIndex = 0; this.x = GAME.path[0].x; this.y = GAME.path[0].y; this.type = type; this.frozen = 0; this.slowed = 0; this.silenced = 0; this.wobble = Math.random() * 10; this.attackTimer = 0; this.damage = 10 + GAME.wave * 2; this.shrink = 1.0; let waveMult = GAME.wave; if (type === 'boss') { this.hp = 1200 + (waveMult * 400); this.speed = 0.5; this.r = 35 + waveMult; this.bounty = 0; this.damage = 80 + waveMult * 10; this.isBoss = true; } else if (type === 'swarm') { this.hp = 40 + (waveMult * 10); this.speed = 3.5; this.r = 10; this.bounty = 8; } else if (type === 'tank') { this.hp = 300 + (waveMult * 80); this.speed = 0.9; this.r = 22; this.bounty = 30; this.damage = 30; } else { this.hp = 120 + (waveMult * 35); this.speed = 2.0; this.r = 14; this.bounty = 15; } this.maxHp = this.hp; }
    update() { this.wobble += 0.2; if (this.frozen > 0) { this.frozen--; return; } if (this.silenced > 0) this.silenced--; let target = GAME.path[this.pathIndex + 1]; if (!target) return; let dx = target.x - this.x; let dy = target.y - this.y; let dist = Math.hypot(dx, dy); let spd = this.speed * (this.slowed > 0 ? 0.15 : 1.0); if (this.slowed > 0) this.slowed--; let blocker = null; if (this.silenced <= 0) { let allDefenders = GAME.soldiers.concat(GAME.heroes); allDefenders.sort((a,b) => (a.isHero === b.isHero) ? 0 : a.isHero ? -1 : 1); for (let s of allDefenders) { if (Math.hypot(s.x - this.x, s.y - this.y) < this.r + (s.isHero ? 40 : 20)) { blocker = s; break; } } } if (blocker) { if (this.attackTimer <= 0) { blocker.takeDamage(this.damage); this.attackTimer = 60; GAME.particles.push(new Particle(blocker.x, blocker.y, '#ef4444', 1)); } } else { this.x += (dx/dist) * spd; this.y += (dy/dist) * spd; } if (this.attackTimer > 0) this.attackTimer--; if (dist < spd) { this.pathIndex++; if (this.pathIndex >= GAME.path.length - 1) this.reachedBase(); } }
    draw() { ctx.save(); ctx.translate(this.x, this.y); let s = (1 + Math.sin(this.wobble)*0.08) * this.shrink; ctx.scale(s, s); if (this.type === 'boss') { ctx.fillStyle = `hsl(${270 + GAME.wave * 10}, 70%, 40%)`; ctx.beginPath(); ctx.arc(0,0,this.r,0,Math.PI*2); ctx.fill(); ctx.fillStyle = '#000'; let spikeCount = 6 + Math.min(8, Math.floor(GAME.wave/2)); for(let i=0; i<spikeCount; i++) { let a = (i/spikeCount)*Math.PI*2 + this.wobble*0.1; ctx.beginPath(); ctx.arc(Math.cos(a)*this.r, Math.sin(a)*this.r, 8, 0, Math.PI*2); ctx.fill(); } ctx.fillStyle = '#fff'; ctx.font='24px Arial'; ctx.fillText('üëπ', -12, 10); } else if (this.type === 'swarm') { ctx.fillStyle = '#991b1b'; ctx.beginPath(); ctx.moveTo(0, -this.r); ctx.lineTo(this.r, this.r); ctx.lineTo(-this.r, this.r); ctx.fill(); ctx.fillStyle = '#fbbf24'; ctx.beginPath(); ctx.arc(-4, -4, 2, 0, Math.PI*2); ctx.fill(); ctx.beginPath(); ctx.arc(4, -4, 2, 0, Math.PI*2); ctx.fill(); } else if (this.type === 'tank') { ctx.fillStyle = '#374151'; ctx.beginPath(); ctx.roundRect(-this.r, -this.r, this.r*2, this.r*2, 5); ctx.fill(); ctx.fillStyle = '#ef4444'; ctx.beginPath(); ctx.arc(0, -5, 6, 0, Math.PI*2); ctx.fill(); ctx.strokeStyle = '#1f2937'; ctx.lineWidth = 3; ctx.beginPath(); ctx.moveTo(-10, 10); ctx.lineTo(10, 10); ctx.stroke(); } else { ctx.fillStyle = '#3f6212'; ctx.beginPath(); ctx.arc(0, 0, this.r, 0, Math.PI*2); ctx.fill(); ctx.beginPath(); ctx.moveTo(-this.r, 0); ctx.lineTo(-this.r-5, -8); ctx.lineTo(-this.r+2, -5); ctx.fill(); ctx.beginPath(); ctx.moveTo(this.r, 0); ctx.lineTo(this.r+5, -8); ctx.lineTo(this.r-2, -5); ctx.fill(); ctx.fillStyle = '#fca5a5'; ctx.beginPath(); ctx.arc(-5, -2, 4, 0, Math.PI*2); ctx.fill(); ctx.beginPath(); ctx.arc(5, -2, 4, 0, Math.PI*2); ctx.fill(); } ctx.restore(); const pct = Math.max(0, this.hp/this.maxHp); const barW = this.r * 2 * this.shrink; ctx.fillStyle = 'rgba(0,0,0,0.6)'; ctx.fillRect(this.x - barW/2, this.y - this.r*this.shrink - 12, barW, 4); ctx.fillStyle = pct > 0.5 ? '#22c55e' : '#ef4444'; ctx.fillRect(this.x - barW/2, this.y - this.r*this.shrink - 12, barW * pct, 4); if (this.silenced > 0) ctx.fillText('üò∂', this.x, this.y - 30); else if (this.frozen > 0) ctx.fillText('‚ö°', this.x, this.y-25); else if (this.slowed > 0) ctx.fillText('‚ùÑÔ∏è', this.x, this.y-25); }
    takeDamage(amt) { this.hp -= amt; if (this.hp <= 0) { GAME.gold += this.bounty; if (this.isBoss) { let r = 1 + Math.floor(GAME.wave/5); GAME.diamonds += r; showFloatText("+" + r + "üíé", this.x, this.y - 40, '#22d3ee'); } GAME.bloodStains.push(new BloodStain(this.x, this.y)); updateUI(); return true; } return false; }
    reachedBase() { this.hp = 0; GAME.lives -= (this.isBoss ? 5 : 1); AudioSys.playExplosion(); updateUI(); if (GAME.lives <= 0) endGame(); }
}

class Hero {
    constructor(x, y, type) { this.x = x; this.y = y; this.type = type; let stats = HEROES_CONFIG[type]; this.hp = stats.hp; this.maxHp = stats.hp; this.dmg = stats.dmg; this.range = stats.range; this.rate = stats.rate; this.color = stats.color; this.target = null; this.timer = 0; this.isHero = true; if (this.type === 'knight') this.spawnMinions(); }
    spawnMinions() { for(let i=0; i<3; i++) { let sx = this.x + (Math.random()-0.5)*50; let sy = this.y + (Math.random()-0.5)*50; GAME.soldiers.push(new Soldier(sx, sy)); } AudioSys.playBuild(); }
    update() { let decayRate = this.maxHp / 1200; if (this.type === 'knight') decayRate = this.maxHp / 2400; if (this.type === 'deathgod') { let drained = false; let targets = [...GAME.enemies, ...GAME.zombies]; for (let t of targets) { if (Math.hypot(t.x-this.x, t.y-this.y) < 120) { t.takeDamage(1); t.shrink = Math.max(0.4, t.shrink - 0.005); this.hp += 5; drained = true; if(Math.random()<0.1) { GAME.particles.push(new Particle(t.x, t.y, '#000', 1)); AudioSys.playSuck(); } } } decayRate = drained ? 0 : this.maxHp / 200; } this.hp -= decayRate; let nearest = null; let minD = 300; let allTargets = [...GAME.enemies, ...GAME.zombies]; for (let e of allTargets) { let d = Math.hypot(e.x - this.x, e.y - this.y); if (d < minD) { minD = d; nearest = e; } } if (nearest) { let dist = Math.hypot(nearest.x - this.x, nearest.y - this.y); if (this.type === 'knight' || this.type === 'deathgod') { if (dist > 30) { let dx = nearest.x - this.x; let dy = nearest.y - this.y; this.x += (dx/dist)*1.2; this.y += (dy/dist)*1.2; } } else { if (dist > this.range) { let dx = nearest.x - this.x; let dy = nearest.y - this.y; this.x += (dx/dist)*1.0; this.y += (dy/dist)*1.0; } } if (dist <= this.range && this.timer <= 0) { if (this.type === 'ranger') { GAME.projectiles.push(new Projectile(this.x, this.y, nearest, 'arrow', this.dmg)); AudioSys.playShoot(); this.timer = this.rate; } else if (this.type === 'sorcerer') { GAME.poisonTraps.push(new PoisonTrap(nearest.x, nearest.y)); AudioSys.playPoison(); this.timer = this.rate; } else if (this.type === 'deathgod') { nearest.takeDamage(this.dmg); this.timer = this.rate; } else { nearest.takeDamage(this.dmg); AudioSys.playZap(); this.timer = this.rate; } } } if(this.timer > 0) this.timer--; }
    takeDamage(amt) { this.hp -= amt; return this.hp <= 0; }
    draw() { ctx.save(); ctx.translate(this.x, this.y); ctx.fillStyle = 'rgba(0,0,0,0.3)'; ctx.beginPath(); ctx.ellipse(0, 15, 12, 6, 0, 0, Math.PI*2); ctx.fill(); if (this.type === 'deathgod') { ctx.shadowBlur = 15; ctx.shadowColor = '#000'; } ctx.fillStyle = this.type === 'knight' ? '#b91c1c' : (this.type === 'ranger' ? '#14532d' : (this.type === 'sorcerer' ? '#0f766e' : '#000')); if (this.type === 'deathgod') ctx.fillStyle = '#111'; ctx.beginPath(); ctx.moveTo(-10, -10); ctx.lineTo(10, -10); ctx.lineTo(15, 25); ctx.quadraticCurveTo(0, 30, -15, 25); ctx.fill(); ctx.fillStyle = this.color; ctx.beginPath(); ctx.arc(0, -5, 10, 0, Math.PI*2); ctx.fill(); if (this.type === 'knight') { ctx.fillStyle = '#e2e8f0'; ctx.fillRect(-8, -12, 16, 14); ctx.fillStyle = '#cbd5e1'; ctx.translate(12, 0); ctx.rotate(-0.5); ctx.fillRect(-2, -20, 4, 30); ctx.fillStyle = '#f59e0b'; ctx.fillRect(-6, 0, 12, 4); ctx.rotate(0.5); ctx.translate(-12, 0); ctx.fillStyle = '#f59e0b'; ctx.beginPath(); ctx.arc(-10, 2, 8, 0, Math.PI*2); ctx.fill(); } else if (this.type === 'ranger') { ctx.fillStyle = '#166534'; ctx.beginPath(); ctx.arc(0,-8, 11, Math.PI, 0); ctx.fill(); ctx.strokeStyle = '#a16207'; ctx.lineWidth = 2; ctx.beginPath(); ctx.arc(-10, 0, 12, -Math.PI/2, Math.PI/2); ctx.stroke(); ctx.strokeStyle = '#fff'; ctx.lineWidth = 1; ctx.beginPath(); ctx.moveTo(-10, -12); ctx.lineTo(-10, 12); ctx.stroke(); } else if (this.type === 'sorcerer') { ctx.fillStyle = '#134e4a'; ctx.beginPath(); ctx.moveTo(-10, -20); ctx.lineTo(10, -20); ctx.lineTo(15, 25); ctx.lineTo(-15, 25); ctx.fill(); ctx.fillStyle = '#22c55e'; ctx.beginPath(); ctx.arc(15, -5, 5, 0, Math.PI*2); ctx.fill(); ctx.fillStyle = '#fff'; ctx.fillText('üß™', -12, -20); } else if (this.type === 'deathgod') { ctx.fillStyle = '#000'; ctx.beginPath(); ctx.moveTo(-12,-15); ctx.lineTo(12,-15); ctx.lineTo(0,-30); ctx.fill(); ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.arc(0, -10, 6, 0, Math.PI*2); ctx.fill(); ctx.fillStyle = '#000'; ctx.beginPath(); ctx.arc(-2, -10, 2, 0, Math.PI*2); ctx.arc(2, -10, 2, 0, Math.PI*2); ctx.fill(); ctx.translate(15, 0); ctx.rotate(0.3); ctx.fillStyle = '#555'; ctx.fillRect(-2, -20, 4, 45); ctx.fillStyle = '#cbd5e1'; ctx.beginPath(); ctx.arc(0, -20, 15, Math.PI, 0); ctx.lineTo(0, -20); ctx.fill(); ctx.rotate(-0.3); ctx.translate(-15, 0); } ctx.shadowBlur = 0; ctx.fillStyle = 'rgba(0,0,0,0.5)'; ctx.fillRect(-15, -35, 30, 4); ctx.fillStyle = '#0f0'; ctx.fillRect(-15, -35, 30 * (Math.max(0,this.hp)/this.maxHp), 4); ctx.restore(); }
}

class Tower {
    constructor(x, y, type) { this.x = x; this.y = y; this.type = type; this.level = 1; const base = TOWERS_BASE[type]; this.damage = base.damage; this.range = base.range; this.rate = base.rate; this.cooldown = 0; this.angle = 0; this.baseCost = base.cost; this.totalValue = base.cost; this.maxHp = base.hp || 500; this.hp = this.maxHp; }
    upgrade() { this.level++; this.totalValue += this.getUpgradeCost(); this.damage *= 1.4; this.range *= 1.05; this.maxHp *= 1.5; this.hp = this.maxHp; if (this.rate > 5) this.rate *= 0.9; GAME.particles.push(new Particle(this.x, this.y, '#fbbf24', 3)); AudioSys.playUpgrade(); }
    getUpgradeCost() { return Math.floor(this.baseCost * Math.pow(1.5, this.level)); }
    getSellPrice() { return Math.floor(this.totalValue * 0.7); }
    update() { if (this.cooldown > 0) this.cooldown--; let targets = [...GAME.enemies, ...GAME.zombies].filter(e => Math.hypot(e.x - this.x, e.y - this.y) <= this.range); if (targets.length === 0) return; targets.sort((a,b) => (Math.hypot(a.x-this.x, a.y-this.y) - Math.hypot(b.x-this.x, b.y-this.y))); let target = targets[0]; this.angle = Math.atan2(target.y - this.y, target.x - this.x); if (this.cooldown <= 0) { this.shoot(target, targets); this.cooldown = this.rate; } }
    shoot(target, allTargets) { const stats = TOWERS_BASE[this.type]; this.hp = Math.min(this.maxHp, this.hp + this.damage * 0.1); if (this.type === 'archer') { GAME.projectiles.push(new Projectile(this.x, this.y, target, 'arrow', this.damage)); AudioSys.playShoot(); } else if (this.type === 'cannon') { let bx = this.x + Math.cos(this.angle)*20; let by = this.y + Math.sin(this.angle)*20; GAME.projectiles.push(new Projectile(bx, by, target, 'bomb', this.damage, stats.aoe)); AudioSys.playCannon(); GAME.particles.push(new Particle(bx, by, '#9ca3af')); } else if (this.type === 'mage') { target.takeDamage(this.damage); target.slowed = 40; this.laserTarget = {x: target.x, y: target.y, timer: 6}; AudioSys.playMagic(); } else if (this.type === 'tesla') { let count = 0; this.visualBolts = []; for (let t of allTargets) { if (count >= stats.multi + Math.floor(this.level/2)) break; t.takeDamage(this.damage); t.frozen = stats.stun; this.visualBolts.push({x: t.x, y: t.y, timer: 10}); count++; } AudioSys.playZap(); } }
    takeDamage(amount) { this.hp -= amount; if (this.hp <= 0) return true; return false; }
    draw() { ctx.save(); ctx.translate(this.x, this.y); if (GAME.selectedTower === this) { ctx.beginPath(); ctx.arc(0,0, this.range, 0, Math.PI*2); ctx.fillStyle = 'rgba(255,255,255,0.1)'; ctx.fill(); ctx.strokeStyle = '#fff'; ctx.setLineDash([5,5]); ctx.stroke(); ctx.setLineDash([]); } if (this.level > 1) { ctx.fillStyle = '#facc15'; ctx.font = 'bold 10px Arial'; ctx.fillText('Lv.'+this.level, -10, -28); } ctx.fillStyle = '#4b5563'; ctx.beginPath(); ctx.arc(0, 0, 22, 0, Math.PI*2); ctx.fill(); ctx.strokeStyle = '#374151'; ctx.lineWidth = 2; ctx.stroke(); if (this.type === 'archer') { ctx.rotate(this.angle); ctx.fillStyle = '#92400e'; ctx.fillRect(-12, -12, 24, 24); ctx.strokeStyle = '#fcd34d'; ctx.lineWidth = 4; ctx.beginPath(); ctx.arc(5, 0, 20, Math.PI*0.75, Math.PI*1.25); ctx.stroke(); ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(25, 0); ctx.lineTo(20, -4); ctx.moveTo(25, 0); ctx.lineTo(20, 4); ctx.stroke(); } else if (this.type === 'cannon') { ctx.rotate(this.angle); ctx.fillStyle = '#1f2937'; ctx.beginPath(); ctx.arc(0, 0, 15, 0, Math.PI*2); ctx.fill(); ctx.fillStyle = '#000'; ctx.fillRect(0, -10, 32, 20); ctx.fillStyle = '#374151'; ctx.fillRect(5, -6, 20, 12); } else if (this.type === 'mage') { ctx.fillStyle = '#6b21a8'; ctx.beginPath(); ctx.moveTo(0, -15); ctx.lineTo(12, 12); ctx.lineTo(-12, 12); ctx.fill(); ctx.fillStyle = '#a855f7'; ctx.beginPath(); ctx.moveTo(0, -25); ctx.lineTo(8, -10); ctx.lineTo(-8, -10); ctx.fill(); ctx.rotate(this.angle); ctx.strokeStyle = '#818cf8'; ctx.lineWidth = 3; ctx.beginPath(); ctx.moveTo(5, 5); ctx.lineTo(18, 10); ctx.stroke(); ctx.fillStyle = '#38bdf8'; ctx.beginPath(); ctx.arc(20, 11, 4, 0, Math.PI*2); ctx.fill(); } else if (this.type === 'tesla') { ctx.fillStyle = '#334155'; ctx.fillRect(-10, -15, 20, 30); ctx.strokeStyle = '#b45309'; ctx.lineWidth = 3; ctx.beginPath(); for(let i=-10; i<10; i+=5) { ctx.moveTo(-10, i); ctx.lineTo(10, i); } ctx.stroke(); ctx.fillStyle = '#0ea5e9'; ctx.shadowBlur = 10; ctx.shadowColor = '#0ea5e9'; ctx.beginPath(); ctx.arc(0, -18, 10, 0, Math.PI*2); ctx.fill(); ctx.shadowBlur = 0; ctx.fillStyle = '#fff'; ctx.font = '14px Arial'; ctx.fillText('‚ö°', -6, -13); } ctx.restore(); ctx.fillStyle = 'red'; ctx.fillRect(this.x - 15, this.y + 25, 30, 4); ctx.fillStyle = '#0f0'; ctx.fillRect(this.x - 15, this.y + 25, 30 * (this.hp/this.maxHp), 4); if (this.type === 'mage' && this.laserTarget && this.laserTarget.timer > 0) { ctx.strokeStyle = `rgba(168, 85, 247, ${this.laserTarget.timer/6})`; ctx.lineWidth = 4; ctx.beginPath(); ctx.moveTo(this.x, this.y - 20); ctx.lineTo(this.laserTarget.x, this.laserTarget.y); ctx.stroke(); this.laserTarget.timer--; } if (this.type === 'tesla' && this.visualBolts) { for(let b of this.visualBolts) { if(b.timer > 0) { ctx.beginPath(); ctx.moveTo(this.x, this.y-18); let midX = (this.x+b.x)/2 + (Math.random()*40-20); let midY = (this.y+b.y)/2 + (Math.random()*40-20); ctx.lineTo(midX, midY); ctx.lineTo(b.x, b.y); ctx.strokeStyle = '#bae6fd'; ctx.lineWidth = 2; ctx.stroke(); b.timer--; } } } }
}

class Projectile {
    constructor(x, y, target, type, dmg, aoe=0) { this.x = x; this.y = y; this.target = target; this.tx = target.x; this.ty = target.y; this.type = type; this.dmg = dmg; this.aoe = aoe; this.speed = type === 'arrow' ? 12 : 7; this.active = true; }
    update() { if (this.target && this.target.hp > 0) { this.tx = this.target.x; this.ty = this.target.y; } let dx = this.tx - this.x; let dy = this.ty - this.y; let dist = Math.hypot(dx, dy); if (dist < this.speed) { this.active = false; if (this.type === 'bomb') { let targets = [...GAME.enemies, ...GAME.zombies]; targets.forEach(e => { if (Math.hypot(e.x - this.x, e.y - this.y) < this.aoe) e.takeDamage(this.dmg); }); GAME.particles.push(new Particle(this.x, this.y, '#f97316', 3)); AudioSys.playExplosion(); ctx.beginPath(); ctx.arc(this.x, this.y, this.aoe, 0, Math.PI*2); ctx.fillStyle='rgba(239,68,68,0.4)'; ctx.fill(); } else { if(this.target) this.target.takeDamage(this.dmg); } } else { this.x += (dx/dist)*this.speed; this.y += (dy/dist)*this.speed; } }
    draw() { ctx.fillStyle = this.type === 'arrow' ? '#fef08a' : '#000'; ctx.beginPath(); ctx.arc(this.x, this.y, this.type==='arrow'?3:5, 0, Math.PI*2); ctx.fill(); }
}

class Soldier {
    constructor(x, y) { this.x = x; this.y = y; this.hp = 120; this.maxHp = 120; this.target = null; this.timer = 0; }
    update() { let nearest = null; let minD = 100; let targets = [...GAME.enemies, ...GAME.zombies]; for (let e of targets) { let d = Math.hypot(e.x - this.x, e.y - this.y); if (d < minD) { minD = d; nearest = e; } } if (nearest) { if (Math.hypot(nearest.x-this.x, nearest.y-this.y) < 25) { if (this.timer <= 0) { nearest.takeDamage(8); this.hp -= 3; this.timer = 40; } } else { let dx=nearest.x-this.x; let dy=nearest.y-this.y; let d=Math.hypot(dx,dy); this.x+=(dx/d)*1.5; this.y+=(dy/d)*1.5; } } if(this.timer>0) this.timer--; }
    takeDamage(amt) { this.hp -= amt; return this.hp <= 0; }
    draw() { ctx.fillStyle = '#2563eb'; ctx.beginPath(); ctx.arc(this.x, this.y, 10, 0, Math.PI*2); ctx.fill(); ctx.fillStyle = '#94a3b8'; ctx.beginPath(); ctx.arc(this.x, this.y, 6, 0, Math.PI*2); ctx.fill(); ctx.fillStyle = '#1e3a8a'; ctx.beginPath(); ctx.ellipse(this.x-8, this.y, 4, 8, 0, 0, Math.PI*2); ctx.fill(); ctx.strokeStyle = '#fbbf24'; ctx.lineWidth=1; ctx.stroke(); if (this.timer > 20) { ctx.save(); ctx.translate(this.x+8, this.y); ctx.rotate(Math.PI/4); ctx.fillStyle='#e2e8f0'; ctx.fillRect(0,-8,2,16); ctx.restore(); } ctx.fillStyle = '#0f0'; ctx.fillRect(this.x-8, this.y-12, 16*(this.hp/this.maxHp), 3); }
}

class Particle {
    constructor(x, y, col, size=1) { this.x = x; this.y = y; this.col = col; this.size = size + Math.random()*2; this.vx = (Math.random()-0.5)*5; this.vy = (Math.random()-0.5)*5; this.life = 1.0; }
    update() { this.x+=this.vx; this.y+=this.vy; this.life-=0.05; }
    draw() { ctx.globalAlpha=Math.max(0,this.life); ctx.fillStyle=this.col; ctx.beginPath(); ctx.arc(this.x,this.y,this.size,0,Math.PI*2); ctx.fill(); ctx.globalAlpha=1; }
}

class Meteor {
    constructor(tx, ty) {
        this.tx = tx; this.ty = ty;
        this.y = -200; this.x = tx - 100; // Start higher up
        this.speed = 10;
        this.active = true; // Initialize active state
        this.angle = Math.atan2(this.ty - this.y, this.tx - this.x);
    }
    update() {
        let dx = this.tx - this.x;
        let dy = this.ty - this.y;
        let dist = Math.hypot(dx, dy);
        
        if (dist < this.speed) {
            // Impact
            this.active = false;
            AudioSys.playMeteor();
            GAME.particles.push(new Particle(this.tx, this.ty, '#fbbf24', 10)); // Big explosion
            
            // Damage Logic
            let targets = [...GAME.enemies, ...GAME.zombies];
            targets.forEach(e => {
                if (Math.hypot(e.x - this.tx, e.y - this.ty) < 200) { // Radius 200
                    e.takeDamage(800); // Massive DMG
                }
            });
            GAME.craters.push(new Crater(this.tx, this.ty));
        } else {
            this.x += Math.cos(this.angle) * this.speed;
            this.y += Math.sin(this.angle) * this.speed;
        }
    }
    draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.angle);
        
        // Trail
        ctx.fillStyle = 'rgba(251, 191, 36, 0.6)';
        ctx.beginPath();
        ctx.moveTo(0, -10);
        ctx.lineTo(-80 + Math.random()*20, 0); // Flickering tail
        ctx.lineTo(0, 10);
        ctx.fill();

        // Core
        ctx.fillStyle = '#ea580c'; // Orange Red
        ctx.beginPath(); ctx.arc(0, 0, 20, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = '#fff'; 
        ctx.beginPath(); ctx.arc(-5, -5, 5, 0, Math.PI*2); ctx.fill(); // Shine
        
        ctx.restore();
    }
}

class Crater {
    constructor(x, y) { this.x=x; this.y=y; this.life=120; } // 2 seconds
    draw() {
        ctx.globalAlpha = this.life/120;
        ctx.fillStyle = '#374151'; // Dark Ash/Gray
        ctx.beginPath(); ctx.arc(this.x, this.y, 100, 0, Math.PI*2); ctx.fill(); // Full Radius Area
        ctx.globalAlpha = 1.0;
        this.life--;
    }
}

class Truck {
    constructor() {
        let base = GAME.path[GAME.path.length-1];
        this.x = base.x; this.y = base.y;
        this.life = 600; // 10 seconds
        this.shootTimer = 0;
        AudioSys.playTruck();
    }
    update() {
        this.life--;
        // Find zombie
        let target = null; let minD = Infinity;
        GAME.zombies.forEach(z => {
            let d = Math.hypot(z.x - this.x, z.y - this.y);
            if (d < minD) { minD = d; target = z; }
        });

        if (this.life <= 0) {
            // Return to base logic (simplified: move to base then disappear)
            let base = GAME.path[GAME.path.length-1];
            let dx = base.x - this.x; let dy = base.y - this.y;
            let dist = Math.hypot(dx, dy);
            if (dist < 10) return false; // Done
            this.x += (dx/dist)*5; this.y += (dy/dist)*5;
            this.angle = Math.atan2(dy, dx);
        } else if (target) {
            let dx = target.x - this.x; let dy = target.y - this.y;
            let dist = Math.hypot(dx, dy);
            
            // Move fast towards zombie
            if (dist > 100) {
                this.x += (dx/dist)*4; this.y += (dy/dist)*4;
                this.angle = Math.atan2(dy, dx);
            }
            
            // Shoot
            if (this.shootTimer <= 0) {
                GAME.projectiles.push(new Projectile(this.x, this.y, target, 'arrow', 30));
                AudioSys.playShoot();
                this.shootTimer = 10; // Rapid fire
            }
        }
        if(this.shootTimer > 0) this.shootTimer--;
        return true;
    }
    draw() {
        ctx.save(); ctx.translate(this.x, this.y);
        ctx.rotate(this.angle || 0);
        // Truck Body
        ctx.fillStyle = '#1e3a8a'; ctx.fillRect(-20, -10, 40, 20); // Blue Body
        ctx.fillStyle = '#60a5fa'; ctx.fillRect(0, -10, 15, 20); // Cab
        ctx.fillStyle = '#000'; ctx.fillRect(-15, -12, 10, 4); ctx.fillRect(10, -12, 10, 4); // Wheels
        ctx.fillRect(-15, 8, 10, 4); ctx.fillRect(10, 8, 10, 4);
        // Gunner in back
        ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.arc(-10, 0, 5, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = '#000'; ctx.fillRect(-10, -2, 20, 4); // Gun
        ctx.restore();
    }
}

class UFO {
    constructor(tx, ty) {
        this.tx = tx; this.ty = ty; // Landing target
        this.x = tx; this.y = -200; // Start high
        this.life = 900; // 15 seconds
        this.state = 0; // 0: Landing, 1: Landed/Dig effect, 2: Flying
        this.timer = 0;
        this.rotation = 0;
        this.shootTimer = 0;
        this.type = 'ufo';
    }
    update() {
        this.rotation += 0.1;
        
        if (this.state === 0) { // Landing
            this.y += 10;
            if (this.y >= this.ty) {
                this.y = this.ty;
                this.state = 1;
                this.timer = 60; // 1s on ground
                AudioSys.playExplosion();
                // Create dirt particles
                for(let i=0; i<10; i++) GAME.particles.push(new Particle(this.x, this.y, '#78350f', 3));
            }
        } else if (this.state === 1) { // Ground Effect
            this.timer--;
            if (this.timer <= 0) {
                this.state = 2; // Take off
            }
        } else if (this.state === 2) { // Flying
            this.life--;
            if (this.life <= 0) return false; // Despawn

            // Seek Target
            let target = null; let minD = Infinity;
            let targets = [...GAME.enemies, ...GAME.zombies];
            for(let t of targets) {
                let d = Math.hypot(t.x - this.x, t.y - this.y);
                if (d < minD) { minD = d; target = t; }
            }

            if (target) {
                let dx = target.x - this.x; let dy = target.y - this.y;
                let dist = Math.hypot(dx, dy);
                
                // Move very fast to target (hover above)
                if (dist > 50) {
                    this.x += (dx/dist)*8;
                    this.y += (dy/dist)*8;
                }

                // Shoot Laser
                if (this.shootTimer <= 0) {
                    target.takeDamage(50); // High damage
                    this.shootTimer = 10; // Fast fire rate
                    AudioSys.playLaser();
                    // Laser Visual
                    ctx.beginPath();
                    ctx.moveTo(this.x, this.y);
                    ctx.lineTo(target.x, target.y);
                    ctx.strokeStyle = '#0ea5e9';
                    ctx.lineWidth = 4;
                    ctx.stroke();
                    GAME.particles.push(new Particle(target.x, target.y, '#0ea5e9', 2));
                }
            }
            if (this.shootTimer > 0) this.shootTimer--;
        }
        return true;
    }
    draw() {
        ctx.save(); ctx.translate(this.x, this.y);
        
        if (this.state === 1) {
            // Digging effect
            ctx.fillStyle = '#78350f';
            ctx.beginPath(); ctx.ellipse(0, 20, 30, 10, 0, 0, Math.PI*2); ctx.fill();
        }

        // UFO Body
        ctx.fillStyle = '#94a3b8'; // Silver
        ctx.beginPath(); ctx.ellipse(0, 0, 25, 10, 0, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = '#cbd5e1'; // Dome
        ctx.beginPath(); ctx.arc(0, -5, 12, Math.PI, 0); ctx.fill();

        // Rotating Orbs
        for(let i=0; i<7; i++) {
            let a = this.rotation + (i/7)*Math.PI*2;
            let ox = Math.cos(a) * 20;
            let oy = Math.sin(a) * 8;
            ctx.fillStyle = '#38bdf8'; // Cyan
            ctx.beginPath(); ctx.arc(ox, oy, 4, 0, Math.PI*2); ctx.fill();
        }

        // Energy Ring
        ctx.strokeStyle = `rgba(14, 165, 233, ${0.5 + Math.sin(this.rotation*5)*0.3})`;
        ctx.lineWidth = 2;
        ctx.beginPath(); ctx.ellipse(0, 0, 30, 12, 0, 0, Math.PI*2); ctx.stroke();

        ctx.restore();
    }
}

/** GAME CONTROL **/
function startGame() { 
    try {
        AudioSys.init(); 
    } catch(e) {
        console.log("Audio init failed, continuing without audio");
    }
    document.getElementById('start-screen').style.display = 'none'; 
    initMap(); 
    GAME.active = true; 
    startWave(); 
    requestAnimationFrame(gameLoop); 
}
function startWave() { GAME.enemiesToSpawn = []; let count = 6 + GAME.wave * 2; for(let i=0; i<count; i++) { let type = 'normal'; if (GAME.wave > 1 && i % 4 === 0) type = 'swarm'; if (GAME.wave > 2 && i % 6 === 0) type = 'tank'; GAME.enemiesToSpawn.push(type); } GAME.enemiesToSpawn.push('boss'); GAME.spawnTimer = 60; }
function spawnProvokeBoss() { if (!GAME.devMode) return; GAME.provokeCount++; let boss = new Enemy('boss'); boss.hp *= (1 + GAME.provokeCount * 0.5); boss.r = Math.min(80, boss.r + GAME.provokeCount * 2); boss.isProvoked = true; GAME.enemies.push(boss); AudioSys.playExplosion(); showFloatText("BOSS TRI·ªÜU H·ªíI!", boss.x, boss.y - 50, '#ef4444'); }

function castSpell(type) {
    if (!GAME.devMode && GAME.spells[type] > 0) {
        showFloatText("Ch·ªù h·ªìi chi√™u!", window.innerWidth/2, window.innerHeight/2, '#ef4444');
        return;
    }
    
    if (type === 'meteor') {
        resetSelection(); // Reset first to avoid conflicts
        GAME.selection = 'meteor';
        document.body.style.cursor = 'crosshair';
        document.getElementById('btn-meteor').classList.add('selected');
    } else if (type === 'truck') {
        GAME.allies.push(new Truck());
        if (!GAME.devMode) {
            GAME.spells.truck = SPELLS_CONFIG.truck.cd * 60;
            updateSpellCD('truck');
        }
    } else if (type === 'ufo') {
        // Select target area for UFO to land
        resetSelection();
        GAME.selection = 'ufo';
        document.body.style.cursor = 'crosshair';
        document.getElementById('btn-ufo').classList.add('selected');
    }
}

function updateSpellCD(type) {
    let overlay = document.getElementById('cd-'+type);
    if (GAME.spells[type] > 0) {
        GAME.spells[type]--;
        overlay.style.display = 'flex';
        overlay.innerText = Math.ceil(GAME.spells[type] / 60);
    } else {
        overlay.style.display = 'none';
    }
}

function gameLoop() {
    if (!GAME.active || GAME.gameOver) return;
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Spell CD updates
    if (GAME.active && !GAME.gameOver) {
        updateSpellCD('meteor');
        updateSpellCD('truck');
        updateSpellCD('ufo');
    }

    // Crater (Background)
    GAME.craters = GAME.craters.filter(c => c.life > 0); GAME.craters.forEach(c => c.draw());

    GAME.bloodStains = GAME.bloodStains.filter(b => b.life > 0); GAME.bloodStains.forEach(b => b.draw());
    GAME.poisonTraps = GAME.poisonTraps.filter(t => t.life > 0); GAME.poisonTraps.forEach(t => { t.update(); t.draw(); });

    for (let d of GAME.decorations) {
        if(d.type === 'tree') { ctx.fillStyle = 'rgba(0,0,0,0.2)'; ctx.beginPath(); ctx.arc(d.x+5, d.y+5, d.r, 0, Math.PI*2); ctx.fill(); ctx.fillStyle = '#166534'; ctx.beginPath(); ctx.arc(d.x, d.y, d.r, 0, Math.PI*2); ctx.fill(); ctx.fillStyle = '#15803d'; ctx.beginPath(); ctx.arc(d.x, d.y, d.r*0.7, 0, Math.PI*2); ctx.fill(); } else { ctx.fillStyle = '#9ca3af'; ctx.beginPath(); ctx.arc(d.x, d.y, d.r*0.6, 0, Math.PI*2); ctx.fill(); }
    }

    ctx.strokeStyle = '#a8a29e'; ctx.lineWidth = 46; ctx.lineCap = 'round'; ctx.lineJoin = 'round';
    ctx.beginPath(); ctx.moveTo(GAME.path[0].x, GAME.path[0].y); for(let p of GAME.path) ctx.lineTo(p.x, p.y); ctx.stroke();
    ctx.strokeStyle = '#e7e5e4'; ctx.lineWidth = 40; ctx.stroke();

    let start = GAME.path[0]; ctx.fillStyle = '#1f2937'; ctx.beginPath(); ctx.arc(start.x, start.y, 35, 0, Math.PI*2); ctx.fill(); ctx.fillStyle = '#000'; ctx.beginPath(); ctx.arc(start.x, start.y, 25, 0, Math.PI*2); ctx.fill();
    let end = GAME.path[GAME.path.length-1]; ctx.fillStyle = '#2563eb'; ctx.beginPath(); ctx.rect(end.x - 30, end.y - 30, 60, 60); ctx.fill(); ctx.fillStyle = '#1e40af'; ctx.beginPath(); ctx.moveTo(end.x-35, end.y-30); ctx.lineTo(end.x, end.y-55); ctx.lineTo(end.x+35, end.y-30); ctx.fill(); ctx.fillStyle = '#fff'; ctx.font='24px Arial'; ctx.fillText('üè∞', end.x-14, end.y+10);

    for(let s of GAME.slots) {
        if(!s.occupied) { ctx.fillStyle = 'rgba(255,255,255,0.15)'; ctx.strokeStyle = 'rgba(255,255,255,0.3)'; ctx.lineWidth=2; ctx.beginPath(); ctx.arc(s.x,s.y,12,0,Math.PI*2); ctx.fill(); ctx.stroke(); }
    }

    GAME.zombieTimer++;
    if (GAME.zombieTimer > Math.max(100, 300 - GAME.wave * 20)) { GAME.zombieTimer = 0; let type = Math.random() < (0.1 + GAME.wave * 0.05) ? 'big' : 'normal'; GAME.zombies.push(new Zombie(type)); AudioSys.playZombieMoan(); }
    
    GAME.towers = GAME.towers.filter(t => { if (t.hp <= 0) { AudioSys.playExplosion(); GAME.particles.push(new Particle(t.x, t.y, '#333', 3)); let slot = GAME.slots.find(s => Math.hypot(s.x - t.x, s.y - t.y) < 5); if (slot) slot.occupied = false; return false; } t.update(); t.draw(); return true; });
    GAME.zombies = GAME.zombies.filter(z => { z.update(); z.draw(); return z.hp > 0; });

    if (GAME.enemiesToSpawn.length > 0) { GAME.spawnTimer--; if (GAME.spawnTimer <= 0) { GAME.enemies.push(new Enemy(GAME.enemiesToSpawn.shift())); GAME.spawnTimer = GAME.wave < 5 ? 50 : 30; } } else if (GAME.enemies.length === 0) { if(GAME.waveTimer > 0) { GAME.waveDelayTicker--; if(GAME.waveDelayTicker <= 0) { GAME.waveTimer--; GAME.waveDelayTicker = 60; document.getElementById('wave-timer').innerText = `Qu√°i t·ªõi: ${GAME.waveTimer}s`; } } else { GAME.wave++; updateUI(); startWave(); GAME.waveTimer=5; } }

    GAME.enemies.sort((a,b)=>a.y-b.y); GAME.enemies = GAME.enemies.filter(e => { e.update(); e.draw(); return e.hp > 0; });
    if(GAME.soldierCooldown > 0) GAME.soldierCooldown -= 1/60;
    if (GAME.soldierCooldown > 0 && !GAME.devMode) { document.querySelector('#btn-soldier .cost').innerText = Math.ceil(GAME.soldierCooldown) + 's'; } else if (!GAME.devMode) { document.querySelector('#btn-soldier .cost').innerText = 'Free'; }

    GAME.soldiers = GAME.soldiers.filter(s => { s.update(); s.draw(); return s.hp > 0; });
    GAME.heroes = GAME.heroes.filter(h => { h.update(); h.draw(); if (h.hp <= 0) { GAME.particles.push(new Particle(h.x, h.y, h.color, 4)); return false; } return true; });
    
    GAME.allies = GAME.allies.filter(a => { let active = a.update(); a.draw(); return active; });

    GAME.projectiles = GAME.projectiles.filter(p => { p.update(); p.draw(); return p.active; });
    GAME.particles = GAME.particles.filter(p => { p.update(); p.draw(); return p.life>0; });

    if (GAME.selection && !GAME.selectedTower) {
        if (TOWERS_BASE[GAME.selection] || GAME.selection === 'soldier' || HEROES_CONFIG[GAME.selection]) {
            ctx.beginPath(); let range = TOWERS_BASE[GAME.selection]?.range || 20; ctx.arc(mousePos.x, mousePos.y, range, 0, Math.PI*2); ctx.strokeStyle = 'rgba(255,255,255,0.5)'; ctx.stroke();
        } else if (GAME.selection === 'meteor') {
            ctx.beginPath(); ctx.arc(mousePos.x, mousePos.y, 200, 0, Math.PI*2); ctx.strokeStyle = '#f43f5e'; ctx.lineWidth = 2; ctx.stroke();
        } else if (GAME.selection === 'ufo') {
            ctx.beginPath(); ctx.arc(mousePos.x, mousePos.y, 30, 0, Math.PI*2); ctx.strokeStyle = '#0ea5e9'; ctx.lineWidth = 2; ctx.stroke();
        }
    }
    requestAnimationFrame(gameLoop);
}

// ... (Inspector, UI funcs)

function showInspector(tower) {
    document.getElementById('tower-inspector').style.display='block';
    document.getElementById('insp-name').innerText=`${TOWERS_BASE[tower.type].name} (C·∫•p ${tower.level})`;
    document.getElementById('insp-hp').innerText=`${Math.floor(tower.hp)}/${Math.floor(tower.maxHp)}`;
    document.getElementById('insp-dmg').innerText=Math.floor(tower.damage);
    document.getElementById('insp-spd').innerText=(tower.rate/60).toFixed(1)+'s';
    document.getElementById('insp-rng').innerText=Math.floor(tower.range);
    let cost=tower.getUpgradeCost(); document.getElementById('upgrade-cost').innerText=cost+'$';
    document.getElementById('sell-price').innerText=tower.getSellPrice()+'$';
}

function toggleDevMode() {
    GAME.devMode = document.getElementById('devModeToggle').checked;
    const provokeBtn = document.getElementById('btn-provoke');
    
    if (GAME.devMode) {
        GAME.gold = 999999;
        GAME.diamonds = 9999;
        provokeBtn.style.display = 'block';
        showFloatText("DEV MODE ON", window.innerWidth/2, 100, '#22d3ee');
    } else {
        GAME.gold = 500 + (GAME.wave * 100);
        GAME.diamonds = Math.floor(GAME.wave / 5);
        provokeBtn.style.display = 'none';
        showFloatText("DEV MODE OFF", window.innerWidth/2, 100, '#ef4444');
    }
    updateUI();
}

canvas.addEventListener('mousemove', e => mousePos = {x: e.clientX, y: e.clientY});
canvas.addEventListener('click', e => {
    if (!GAME.active) return;
    const x = e.clientX; const y = e.clientY;

    if (GAME.selection === 'meteor') {
        GAME.projectiles.push(new Meteor(x, y));
        if (!GAME.devMode) {
            GAME.spells.meteor = SPELLS_CONFIG.meteor.cd * 60;
            updateSpellCD('meteor');
        }
        document.body.style.cursor = 'default';
        resetSelection();
        return;
    } else if (GAME.selection === 'ufo') {
        GAME.allies.push(new UFO(x, y));
        if (!GAME.devMode) {
            GAME.spells.ufo = SPELLS_CONFIG.ufo.cd * 60;
            updateSpellCD('ufo');
        }
        document.body.style.cursor = 'default';
        resetSelection();
        return;
    }

    let clickedTower = null;
    for(let t of GAME.towers) { if(Math.hypot(t.x - x, t.y - y) < 30) { clickedTower = t; break; } }
    if (clickedTower) { GAME.selectedTower = clickedTower; GAME.selection = null; showInspector(clickedTower); return; }
    if (!clickedTower && GAME.selectedTower) closeInspector();

    if (GAME.selection === 'soldier') {
        if(GAME.soldierCooldown <= 0 || GAME.devMode) {
            GAME.soldiers.push(new Soldier(x, y)); GAME.soldierCooldown = GAME.soldierMaxCooldown; AudioSys.playBuild(); resetSelection();
        }
    } else if (HEROES_CONFIG[GAME.selection]) {
        let cost = HEROES_CONFIG[GAME.selection].cost;
        if (GAME.diamonds >= cost || GAME.devMode) {
            if (!GAME.devMode) GAME.diamonds -= cost;
            GAME.heroes.push(new Hero(x, y, GAME.selection)); AudioSys.playHeroSummon(); updateUI(); resetSelection();
        } else showFloatText("Thi·∫øu Kim C∆∞∆°ng!", x, y, '#22d3ee');
    } else if (TOWERS_BASE[GAME.selection]) {
        let nearest = GAME.slots.find(s => !s.occupied && Math.hypot(s.x-x, s.y-y) < 30);
        if (nearest) {
            let cost = TOWERS_BASE[GAME.selection].cost;
            if (GAME.gold >= cost || GAME.devMode) {
                if (!GAME.devMode) GAME.gold -= cost;
                let t = new Tower(nearest.x, nearest.y, GAME.selection); GAME.towers.push(t); nearest.occupied = true; nearest.towerRef = t; AudioSys.playBuild(); updateUI(); resetSelection();
            } else showFloatText("Thi·∫øu ti·ªÅn!", x, y, '#ef4444');
        }
    }
});

function toggleMenu() { document.getElementById('menu-container').classList.toggle('collapsed'); }
function selectTower(type) { closeInspector(); resetSelection(); GAME.selection=type; document.getElementById('btn-'+type).classList.add('selected'); }
function selectSoldier() { if(GAME.soldierCooldown>0 && !GAME.devMode) return; closeInspector(); resetSelection(); GAME.selection='soldier'; document.getElementById('btn-soldier').classList.add('selected'); }
function selectHero(type) { closeInspector(); resetSelection(); if (!GAME.devMode && GAME.diamonds < HEROES_CONFIG[type].cost) return; GAME.selection=type; document.getElementById('btn-'+type).classList.add('selected'); }
function resetSelection() { GAME.selection=null; document.querySelectorAll('.tower-btn').forEach(b => b.classList.remove('selected')); }
function closeInspector() { GAME.selectedTower=null; document.getElementById('tower-inspector').style.display='none'; }
function upgradeSelectedTower() {
    if(!GAME.selectedTower) return; let cost=GAME.selectedTower.getUpgradeCost();
    if(GAME.gold>=cost || GAME.devMode) { if(!GAME.devMode) GAME.gold-=cost; GAME.selectedTower.upgrade(); updateUI(); showInspector(GAME.selectedTower); showFloatText("N√¢ng c·∫•p!", GAME.selectedTower.x, GAME.selectedTower.y-20, '#facc15'); }
    else showFloatText("Kh√¥ng ƒë·ªß ti·ªÅn!", GAME.selectedTower.x, GAME.selectedTower.y-20, '#ef4444');
}
function sellSelectedTower() {
    if(!GAME.selectedTower) return; let refund=GAME.selectedTower.getSellPrice(); GAME.gold+=refund; AudioSys.playSell();
    GAME.towers=GAME.towers.filter(t=>t!==GAME.selectedTower);
    let slot=GAME.slots.find(s=>Math.hypot(s.x-GAME.selectedTower.x, s.y-GAME.selectedTower.y)<5); if(slot) { slot.occupied=false; }
    showFloatText("+"+refund+"$", GAME.selectedTower.x, GAME.selectedTower.y-20, '#fbbf24'); closeInspector(); updateUI();
}
function updateUI() {
    document.getElementById('lives').innerText=GAME.lives; document.getElementById('gold').innerText=GAME.gold; document.getElementById('diamonds').innerText=GAME.diamonds; document.getElementById('wave').innerText=GAME.wave;
    ['archer','cannon','mage','tesla'].forEach(t=> { let b=document.getElementById('btn-'+t); if(GAME.gold<TOWERS_BASE[t].cost && !GAME.devMode) b.classList.add('disabled'); else b.classList.remove('disabled'); });
    let sBtn=document.getElementById('btn-soldier'); if(GAME.soldierCooldown>0 && !GAME.devMode) { sBtn.classList.add('disabled'); sBtn.querySelector('.cost').innerText=Math.ceil(GAME.soldierCooldown)+'s'; } else { sBtn.classList.remove('disabled'); sBtn.querySelector('.cost').innerText='Free'; }
    for (let h in HEROES_CONFIG) { let b = document.getElementById('btn-'+h); if (GAME.diamonds < HEROES_CONFIG[h].cost && !GAME.devMode) b.classList.add('disabled'); else b.classList.remove('disabled'); }
}
function showFloatText(txt, x, y, col) { let el=document.createElement('div'); el.className='floating-text'; el.innerText=txt; el.style.left=x+'px'; el.style.top=y+'px'; el.style.color=col; document.getElementById('floating-text-container').appendChild(el); setTimeout(()=>el.remove(), 1000); }
function endGame() { GAME.gameOver=true; document.getElementById('game-over-screen').style.display='flex'; document.getElementById('final-wave').innerText=GAME.wave; }
</script>
</body>
</html>