<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Neon UFO: Galactic War</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');

        * { box-sizing: border-box; touch-action: none; user-select: none; -webkit-user-select: none; }
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Orbitron', sans-serif; }
        
        canvas { display: block; position: absolute; top: 0; left: 0; z-index: 1; }
        
        /* UI LAYER */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 10;
            pointer-events: none;
            display: flex; flex-direction: column; justify-content: space-between;
        }

        /* HEADER INFO */
        .hud-top {
            display: flex; justify-content: space-between; align-items: center;
            padding: 15px 20px;
            background: linear-gradient(to bottom, rgba(0,0,0,0.8), transparent);
        }
        .score-box { 
            color: #00ffcc; font-size: 20px; font-weight: 900; letter-spacing: 2px;
            text-shadow: 0 0 10px #00ffcc;
        }
        .hp-container {
            width: 200px; height: 12px; background: rgba(255,255,255,0.1);
            border: 1px solid rgba(0,255,204,0.3); transform: skewX(-20deg);
            position: relative;
        }
        .hp-bar {
            width: 100%; height: 100%; background: #00ffcc;
            box-shadow: 0 0 10px #00ffcc; transition: width 0.2s;
        }
        
        /* WARNING BOSS TEXT */
        #warning-msg {
            position: absolute; top: 20%; left: 50%; transform: translateX(-50%);
            color: #ff0000; font-size: 24px; font-weight: bold; text-align: center;
            text-shadow: 0 0 10px #ff0000; display: none;
            animation: blink 0.5s infinite;
        }
        @keyframes blink { 0% { opacity: 1; } 50% { opacity: 0; } 100% { opacity: 1; } }

        /* JOYSTICK ZONE */
        #joystick-zone {
            position: absolute; bottom: 0; left: 0; width: 50%; height: 60%;
            pointer-events: auto;
        }

        /* SKILL BUTTONS */
        .skill-container {
            position: absolute; bottom: 30px; right: 20px;
            display: flex; flex-direction: column; gap: 15px;
            pointer-events: auto; align-items: flex-end;
        }
        
        .skill-btn {
            width: 75px; height: 75px; border-radius: 12px;
            background: rgba(10, 20, 30, 0.85);
            border: 2px solid rgba(255,255,255,0.1);
            backdrop-filter: blur(10px);
            display: flex; flex-direction: column;
            justify-content: center; align-items: center;
            position: relative; overflow: hidden;
            transition: transform 0.1s;
            box-shadow: 0 4px 15px rgba(0,0,0,0.5);
            cursor: pointer;
        }
        .skill-btn:active { transform: scale(0.95); }
        
        .skill-icon { font-size: 24px; margin-bottom: 2px; }
        .skill-name { font-size: 9px; font-weight: bold; text-transform: uppercase; text-align: center; }
        .skill-cooldown {
            position: absolute; bottom: 0; left: 0; width: 100%; height: 0%;
            background: rgba(0, 0, 0, 0.8); transition: height 0.1s linear;
        }

        /* Skill Colors */
        #skill1 { border-color: #ff3366; color: #ff3366; text-shadow: 0 0 8px #ff3366; }
        #skill2 { border-color: #33ccff; color: #33ccff; text-shadow: 0 0 8px #33ccff; }
        #skill3 { border-color: #ffcc00; color: #ffcc00; text-shadow: 0 0 8px #ffcc00; }

        /* START MENU */
        #menu {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 20;
            background: rgba(5, 5, 10, 0.95);
            display: flex; flex-direction: column;
            justify-content: center; align-items: center; pointer-events: auto;
        }
        h1 {
            font-size: 40px; color: #fff; text-align: center; margin-bottom: 10px;
            background: linear-gradient(to right, #00ffcc, #3399ff);
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
            filter: drop-shadow(0 0 20px rgba(0,255,204,0.5));
        }
        p { color: #8899aa; margin-bottom: 30px; text-align: center; font-size: 13px; line-height: 1.6; max-width: 80%; }
        button.start-btn {
            background: transparent; color: #00ffcc; padding: 15px 40px; font-size: 18px; font-family: 'Orbitron';
            border: 2px solid #00ffcc; text-transform: uppercase; cursor: pointer;
            box-shadow: 0 0 15px rgba(0,255,204,0.2); transition: 0.3s; font-weight: bold;
        }
        .hidden { display: none !important; }
    </style>
</head>
<body>

<div id="ui-layer">
    <div class="hud-top">
        <div class="score-box">ƒêI·ªÇM: <span id="scoreVal">0</span></div>
        <div class="hp-container"><div class="hp-bar" id="hpBar"></div></div>
    </div>
    <div id="warning-msg">‚ö† C·∫¢NH B√ÅO: QU√ÅI V·∫¨T KH·ªîNG L·ªí ‚ö†</div>

    <div id="joystick-zone"></div>

    <div class="skill-container">
        <div class="skill-btn" id="skill3">
            <div class="skill-icon">‚ö°</div>
            <div class="skill-name">B√ÉO ƒê·∫†N</div>
            <div class="skill-cooldown" id="cd3"></div>
        </div>
        <div class="skill-btn" id="skill2">
            <div class="skill-icon">üõ°Ô∏è</div>
            <div class="skill-name">KHI√äN</div>
            <div class="skill-cooldown" id="cd2"></div>
        </div>
        <div class="skill-btn" id="skill1">
            <div class="skill-icon">‚ò¢Ô∏è</div>
            <div class="skill-name">HU·ª∂ DI·ªÜT</div>
            <div class="skill-cooldown" id="cd1"></div>
        </div>
    </div>
</div>

<div id="menu">
    <h1>NEON UFO<br>GALACTIC WAR</h1>
    <p>
        H·ªÜ TH·ªêNG PH√íNG TH·ª¶ TR√ÅI ƒê·∫§T ƒê√É ƒê∆Ø·ª¢C K√çCH HO·∫†T.<br>
        CH√öNG S·∫º B·∫ÆN TR·∫¢! H√ÉY C·∫®N TH·∫¨N V·ªöI C√ÅC T√ÄU CH·ªà HUY.<br><br>
        üïπÔ∏è <b>DI CHUY·ªÇN:</b> K√©o n·ª≠a tr√°i m√†n h√¨nh.<br>
        üî• <b>T·∫§N C√îNG:</b> T·ª± ƒë·ªông b·∫Øn.<br>
        ‚ö† <b>L∆ØU √ù:</b> N√© ƒë·∫°n ƒë·ªè c·ªßa k·∫ª ƒë·ªãch!
    </p>
    <button class="start-btn" id="startBtn">CHI·∫æN ƒê·∫§U</button>
</div>

<canvas id="gameCanvas"></canvas>

<script>
/** * --- SYSTEM --- */
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d', { alpha: false });
let width, height;

function resize() {
    width = canvas.width = window.innerWidth;
    height = canvas.height = window.innerHeight;
}
window.addEventListener('resize', resize);
resize();

// AUDIO (Synth)
const AudioSys = {
    ctx: null,
    init() {
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        this.ctx = new AudioContext();
    },
    play(freq, type, dur, vol = 0.1) {
        if (!this.ctx) return;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = type;
        osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(freq/2, this.ctx.currentTime + dur);
        gain.gain.setValueAtTime(vol, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + dur);
        osc.connect(gain); gain.connect(this.ctx.destination);
        osc.start(); osc.stop(this.ctx.currentTime + dur);
    }
};

/** * --- INPUT --- */
const Input = {
    active: false,
    ox: 0, oy: 0, cx: 0, cy: 0, vx: 0, vy: 0,
    init() {
        const zone = document.getElementById('joystick-zone');
        zone.addEventListener('touchstart', e => this.start(e.touches[0].clientX, e.touches[0].clientY), {passive:false});
        zone.addEventListener('touchmove', e => this.move(e.touches[0].clientX, e.touches[0].clientY), {passive:false});
        zone.addEventListener('touchend', () => this.end());
        let down = false;
        zone.addEventListener('mousedown', e => { down = true; this.start(e.clientX, e.clientY); });
        window.addEventListener('mousemove', e => { if(down) this.move(e.clientX, e.clientY); });
        window.addEventListener('mouseup', () => { down = false; this.end(); });
    },
    start(x, y) { this.active = true; this.ox = x; this.oy = y; this.cx = x; this.cy = y; this.update(); },
    move(x, y) { if(!this.active) return; this.cx = x; this.cy = y; this.update(); },
    end() { this.active = false; this.vx = 0; this.vy = 0; },
    update() {
        const maxR = 60;
        let dx = this.cx - this.ox; let dy = this.cy - this.oy;
        const dist = Math.sqrt(dx*dx + dy*dy);
        if(dist > maxR) { const r = maxR/dist; dx *= r; dy *= r; this.cx = this.ox + dx; this.cy = this.oy + dy; }
        this.vx = dx/maxR; this.vy = dy/maxR;
    }
};

/** --- GAME CLASSES --- */
class Star {
    constructor() {
        this.x = Math.random() * width;
        this.y = Math.random() * height;
        this.size = Math.random() * 2;
        this.depth = Math.random() * 0.5 + 0.1; // Parallax factor
    }
    update(camX, camY, speedX, speedY) {
        // Move opposite to camera movement to create depth
        this.x -= speedX * this.depth;
        this.y -= speedY * this.depth;
        
        // Wrap around screen relative to camera
        // A bit complex with infinite world, simple wrap based on screen view
        if (this.x < 0) this.x = width;
        if (this.x > width) this.x = 0;
        if (this.y < 0) this.y = height;
        if (this.y > height) this.y = 0;
    }
    draw(ctx) {
        ctx.fillStyle = `rgba(255, 255, 255, ${Math.random() * 0.5 + 0.3})`;
        ctx.fillRect(this.x, this.y, this.size, this.size);
    }
}

class Camera {
    constructor() { this.x = 0; this.y = 0; this.shake = 0; }
    update(px, py) {
        this.x = px - width / 2;
        this.y = py - height / 2;
        if (this.shake > 0) {
            this.x += (Math.random()-0.5) * this.shake;
            this.y += (Math.random()-0.5) * this.shake;
            this.shake *= 0.9;
            if(this.shake < 0.5) this.shake = 0;
        }
    }
}

class Player {
    constructor() {
        this.x = 0; this.y = 0;
        this.speed = 5; 
        this.hp = 100; this.maxHp = 100;
        this.angle = 0; this.rotation = 0;
        this.skills = { nuke: { cd: 0, max: 900 }, shield: { cd: 0, max: 600, active: 0 }, multi: { cd: 0, max: 400, active: 0 } };
        this.shootTimer = 0;
    }
    update() {
        this.x += Input.vx * this.speed;
        this.y += Input.vy * this.speed;
        this.rotation += 0.05;
        
        let target = null; let minD = 500;
        enemies.forEach(e => { const d = Math.hypot(e.x - this.x, e.y - this.y); if(d < minD) { minD = d; target = e; } });
        if (target) this.angle = Math.atan2(target.y - this.y, target.x - this.x);
        else if (Input.vx || Input.vy) this.angle = Math.atan2(Input.vy, Input.vx);

        let fireRate = this.skills.multi.active > 0 ? 5 : 15;
        if (this.shootTimer++ > fireRate) {
            this.shootTimer = 0;
            if (this.skills.multi.active > 0) {
                for(let i=0; i<360; i+=45) projectiles.push(new Projectile(this.x, this.y, (this.rotation*5+i)*Math.PI/180, false, '#ffcc00'));
                AudioSys.play(600, 'sawtooth', 0.05);
            } else if (target) {
                projectiles.push(new Projectile(this.x, this.y, this.angle, false, '#00ffcc'));
                AudioSys.play(400, 'sine', 0.1);
            }
        }
        if (this.skills.shield.active > 0) this.skills.shield.active--;
        if (this.skills.multi.active > 0) this.skills.multi.active--;
        for(let k in this.skills) if(this.skills[k].cd > 0) this.skills[k].cd--;
        
        document.getElementById('cd1').style.height = (this.skills.nuke.cd/this.skills.nuke.max*100)+'%';
        document.getElementById('cd2').style.height = (this.skills.shield.cd/this.skills.shield.max*100)+'%';
        document.getElementById('cd3').style.height = (this.skills.multi.cd/this.skills.multi.max*100)+'%';
    }
    draw(ctx) {
        ctx.save(); ctx.translate(this.x, this.y);
        if (this.skills.shield.active > 0) {
            ctx.beginPath(); ctx.arc(0, 0, 50, 0, Math.PI*2);
            ctx.fillStyle = `rgba(50, 200, 255, ${Math.random()*0.2 + 0.1})`;
            ctx.strokeStyle = '#33ccff'; ctx.lineWidth = 2; ctx.fill(); ctx.stroke();
        }
        ctx.rotate(this.rotation);
        ctx.shadowBlur = 20; ctx.shadowColor = '#00ffcc';
        ctx.fillStyle = '#222'; ctx.beginPath(); ctx.arc(0, 0, 25, 0, Math.PI*2); ctx.fill();
        ctx.strokeStyle = '#444'; ctx.lineWidth = 2; ctx.stroke();
        for(let i=0; i<4; i++) { ctx.save(); ctx.rotate(i*Math.PI/2); ctx.fillStyle = '#00ffcc'; ctx.beginPath(); ctx.arc(18, 0, 4, 0, Math.PI*2); ctx.fill(); ctx.restore(); }
        ctx.shadowBlur = 0; ctx.fillStyle = '#000'; ctx.beginPath(); ctx.arc(0, 0, 12, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = 'rgba(0, 255, 204, 0.5)'; ctx.beginPath(); ctx.arc(-3, -3, 5, 0, Math.PI*2); ctx.fill();
        ctx.restore();
    }
    useSkill(id) {
        if (id === 1 && this.skills.nuke.cd <= 0) {
            this.skills.nuke.cd = this.skills.nuke.max;
            Game.cam.shake = 50;
            Game.effects.push({type:'shockwave', x:this.x, y:this.y, color:'#ff3366', life:40, max:40});
            enemies.forEach(e => { if(Math.hypot(e.x-this.x, e.y-this.y)<700) e.takeDamage(100); });
            projectiles = projectiles.filter(p => !p.isEnemy); // Clear enemy bullets
            AudioSys.play(100, 'sawtooth', 0.8);
        }
        if (id === 2 && this.skills.shield.cd <= 0) { this.skills.shield.cd = this.skills.shield.max; this.skills.shield.active = 240; AudioSys.play(600, 'sine', 0.5); }
        if (id === 3 && this.skills.multi.cd <= 0) { this.skills.multi.cd = this.skills.multi.max; this.skills.multi.active = 240; AudioSys.play(800, 'square', 0.5); }
    }
}

class Enemy {
    constructor(x, y, type) {
        this.x = x; this.y = y; this.type = type;
        this.angle = 0; this.shootTimer = Math.random() * 100;
        
        if (type === 'fighter') { // Common
            this.hp = 3; this.speed = 3; this.color = '#ff3333'; this.r = 15; this.score = 20;
        } else if (type === 'cruiser') { // Shooter
            this.hp = 12; this.speed = 1.5; this.color = '#aa00ff'; this.r = 25; this.score = 50;
        } else if (type === 'elite') { // BOSS
            this.hp = 60; this.speed = 2; this.color = '#ff8800'; this.r = 40; this.score = 500;
        }
    }
    update() {
        const dx = player.x - this.x; const dy = player.y - this.y;
        this.angle = Math.atan2(dy, dx);
        const dist = Math.hypot(dx, dy);

        // Movement AI
        if (this.type === 'elite' && dist < 300) {
            // Boss stays at range
        } else {
            this.x += Math.cos(this.angle) * this.speed;
            this.y += Math.sin(this.angle) * this.speed;
        }

        // Shooting AI
        if (this.shootTimer++ > (this.type === 'fighter' ? 120 : (this.type === 'elite' ? 80 : 150))) {
            this.shootTimer = 0;
            if (dist < 700) { // Only shoot if near
                if (this.type === 'fighter') {
                    projectiles.push(new Projectile(this.x, this.y, this.angle, true, '#ff0000'));
                } else if (this.type === 'cruiser') {
                    // Spread shot
                    for(let i=-1; i<=1; i++) projectiles.push(new Projectile(this.x, this.y, this.angle + i*0.2, true, '#aa00ff'));
                } else if (this.type === 'elite') {
                    // Spin shot
                    for(let i=0; i<8; i++) projectiles.push(new Projectile(this.x, this.y, this.angle + i*(Math.PI/4), true, '#ff8800'));
                    AudioSys.play(200, 'square', 0.3);
                }
            }
        }

        // Collision Avoidance
        enemies.forEach(e => {
            if(e===this) return;
            if(Math.hypot(e.x - this.x, e.y - this.y) < this.r + e.r) {
                this.x -= (e.x - this.x) * 0.05;
                this.y -= (e.y - this.y) * 0.05;
            }
        });
    }
    takeDamage(dmg) {
        this.hp -= dmg;
        if (this.hp <= 0) {
            Game.score += this.score;
            Game.cam.shake = (this.type === 'elite' ? 20 : 5);
            Game.effects.push({type:'explosion', x:this.x, y:this.y, color:this.color, life:30, max:30});
            AudioSys.play(100, 'noise', 0.2);
            return true;
        }
        return false;
    }
    draw(ctx) {
        ctx.save(); ctx.translate(this.x, this.y); ctx.rotate(this.angle);
        ctx.shadowBlur = 10; ctx.shadowColor = this.color;
        ctx.strokeStyle = this.color; ctx.lineWidth = 2; ctx.fillStyle = '#111';
        ctx.beginPath();
        if (this.type === 'fighter') { ctx.moveTo(15, 0); ctx.lineTo(-10, 10); ctx.lineTo(-5, 0); ctx.lineTo(-10, -10); }
        else if (this.type === 'cruiser') { ctx.moveTo(20, -10); ctx.lineTo(20, 10); ctx.lineTo(-20, 20); ctx.lineTo(-20, -20); }
        else if (this.type === 'elite') { // Boss Shape
            ctx.rotate(Date.now()/500); 
            for(let i=0; i<6; i++) ctx.lineTo(35 * Math.cos(i*Math.PI/3), 35 * Math.sin(i*Math.PI/3)); 
            ctx.closePath(); ctx.fill(); ctx.stroke(); ctx.beginPath(); ctx.arc(0,0,15,0,Math.PI*2); 
        }
        ctx.closePath(); ctx.fill(); ctx.stroke();
        ctx.restore();
    }
}

class Projectile {
    constructor(x, y, angle, isEnemy, color) {
        this.x = x; this.y = y;
        this.vx = Math.cos(angle) * (isEnemy ? 6 : 12); 
        this.vy = Math.sin(angle) * (isEnemy ? 6 : 12);
        this.isEnemy = isEnemy; this.color = color; this.life = 100;
    }
    update() { this.x += this.vx; this.y += this.vy; this.life--; }
    draw(ctx) {
        ctx.shadowBlur = 10; ctx.shadowColor = this.color; ctx.fillStyle = this.color;
        ctx.beginPath(); ctx.arc(this.x, this.y, this.isEnemy ? 5 : 4, 0, Math.PI*2); ctx.fill();
    }
}

/** --- GAME LOGIC --- */
const Game = {
    loopId: null, score: 0, effects: [], stars: [],
    cam: new Camera(),
    lastEliteScore: 0,

    start() {
        player = new Player(); enemies = []; projectiles = []; this.effects = [];
        this.stars = Array(100).fill().map(() => new Star());
        this.score = 0; this.lastEliteScore = 0;
        Input.init(); AudioSys.init();
        document.getElementById('menu').classList.add('hidden');
        document.getElementById('warning-msg').style.display = 'none';
        this.loop();
    },

    loop() {
        this.loopId = requestAnimationFrame(() => this.loop());
        
        // 1. UPDATE
        player.update();
        this.cam.update(player.x, player.y);
        
        // Stars
        this.stars.forEach(s => s.update(this.cam.x, this.cam.y, Input.vx * player.speed, Input.vy * player.speed));

        // Spawning
        if (Math.random() < 0.025 + (this.score/10000)) {
            const a = Math.random() * Math.PI * 2;
            const d = 700;
            const type = Math.random() > 0.8 ? 'cruiser' : 'fighter';
            enemies.push(new Enemy(player.x + Math.cos(a)*d, player.y + Math.sin(a)*d, type));
        }
        
        // Elite Spawn Logic (Every 500 score)
        if (this.score - this.lastEliteScore >= 500) {
            this.lastEliteScore = this.score;
            const a = Math.random() * Math.PI * 2;
            enemies.push(new Enemy(player.x + Math.cos(a)*800, player.y + Math.sin(a)*800, 'elite'));
            const warn = document.getElementById('warning-msg');
            warn.style.display = 'block';
            setTimeout(() => warn.style.display = 'none', 3000);
            AudioSys.play(100, 'sawtooth', 1, 0.5);
        }

        projectiles.forEach((p, i) => { p.update(); if(p.life <= 0) projectiles.splice(i, 1); });

        // Collisions
        for (let i = projectiles.length - 1; i >= 0; i--) {
            let p = projectiles[i];
            if (p.isEnemy) {
                // Enemy shoots Player
                if (Math.hypot(p.x - player.x, p.y - player.y) < 20) {
                    if (player.skills.shield.active <= 0) {
                        player.hp -= 10;
                        Game.cam.shake = 10;
                        AudioSys.play(100, 'noise', 0.2);
                        if(player.hp <= 0) this.over();
                    }
                    projectiles.splice(i, 1);
                }
            } else {
                // Player shoots Enemy
                for (let j = enemies.length - 1; j >= 0; j--) {
                    let e = enemies[j];
                    if (Math.hypot(p.x - e.x, p.y - e.y) < e.r + 5) {
                        if (e.takeDamage(1)) enemies.splice(j, 1);
                        projectiles.splice(i, 1);
                        break; 
                    }
                }
            }
        }
        
        // Enemy vs Player collision
        enemies.forEach(e => {
            if (Math.hypot(e.x - player.x, e.y - player.y) < e.r + 15) {
                if (player.skills.shield.active <= 0) {
                    player.hp -= 1;
                    if(player.hp <= 0) this.over();
                } else {
                    if(e.type !== 'elite') e.takeDamage(100);
                }
            }
        });

        enemies.forEach(e => e.update());

        // 2. DRAW
        ctx.fillStyle = '#050508'; ctx.fillRect(0, 0, width, height);
        
        // Stars Background (Parallax)
        this.stars.forEach(s => s.draw(ctx));

        ctx.save();
        ctx.translate(-this.cam.x, -this.cam.y);

        projectiles.forEach(p => p.draw(ctx));
        enemies.forEach(e => e.draw(ctx));
        player.draw(ctx);
        
        // Effects
        this.effects.forEach((ef, i) => {
            ef.life--; if(ef.life <= 0) { this.effects.splice(i, 1); return; }
            ctx.save(); ctx.translate(ef.x, ef.y);
            if(ef.type==='explosion') {
                ctx.fillStyle = ef.color; ctx.globalAlpha = ef.life/30;
                ctx.beginPath(); ctx.arc(0,0, (30-ef.life)*2, 0, Math.PI*2); ctx.fill();
            } else if(ef.type==='shockwave') {
                ctx.strokeStyle = ef.color; ctx.lineWidth = 10; ctx.globalAlpha = ef.life/40;
                ctx.beginPath(); ctx.arc(0,0, (40-ef.life)*25, 0, Math.PI*2); ctx.stroke();
            }
            ctx.restore();
        });

        ctx.restore();

        // UI Updates
        document.getElementById('scoreVal').innerText = this.score;
        document.getElementById('hpBar').style.width = Math.max(0, player.hp) + '%';
        
        // Joystick Visual
        if(Input.active) {
            ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.beginPath(); ctx.arc(Input.ox, Input.oy, 60, 0, Math.PI*2); ctx.fill();
            ctx.fillStyle = '#00ffcc';
            ctx.beginPath(); ctx.arc(Input.cx, Input.cy, 20, 0, Math.PI*2); ctx.fill();
        }
    },

    over() {
        cancelAnimationFrame(this.loopId);
        document.getElementById('menu').classList.remove('hidden');
        document.querySelector('#menu h1').innerHTML = "TH·∫§T B·∫†I";
        document.querySelector('#menu p').innerHTML = `ƒêI·ªÇM S·ªê: <b style="color:#fff; font-size:20px">${this.score}</b>`;
        document.getElementById('startBtn').innerText = "TH·ª¨ L·∫†I";
    }
};

document.getElementById('startBtn').addEventListener('click', () => Game.start());
[null, 'skill1', 'skill2', 'skill3'].forEach((id, idx) => {
    if(!id) return;
    const el = document.getElementById(id);
    const use = (e) => { e.preventDefault(); player.useSkill(idx); };
    el.addEventListener('touchstart', use); el.addEventListener('mousedown', use);
});
window.addEventListener('keydown', e => { if(e.key==='1') player.useSkill(3); if(e.key==='2') player.useSkill(2); if(e.key==='3') player.useSkill(1); });

</script>
</body>
</html>